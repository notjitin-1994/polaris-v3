{
  "razorpay-integration": {
    "tasks": [
      {
        "id": 1,
        "title": "Razorpay Account Setup and Enviro"description": "Set up Razorpay business account, complete KYC verification, generate API keys, and configure environment variables",
        "details": "Create Razorpay business account at https://razorpay.com/, complete KYC verification with PAN, GST, and bank details. Generate test mode API keys and enable Subscriptions feature. Configure webhook URL and save webhook secret. Install razorpay@^2.9.4 and @types/razorpay@^2.0.0. Set up environment variables: NEXT_PUBLIC_RAZORPAY_KEY_ID, RAZORPAY_KEY_SECRET, RAZORPAY_WEBHOOK_SECRET, NEXT_PUBLIC_APP_URL, and NEXT_PUBLIC_ENABLE_PAYMENTS=true.",
        "testStrategy": "Verify Razorpay dashboard access, confirm API keys generated, test environment variables accessible server-side only, verify dependencies installed successfully",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Razorpay Business Account and Complete Registration",
            "description": "Set up new Razorpay business account through official website and complete initial registration process",
            "dependencies": [],
            "details": "Navigate to https://razorpay.com/ and create a new business account. Complete the registration form with business details including company name, email, phone number, and business type. Verify email address and phone number through OTP verification. Set up account password and security settings.\n<info added on 2025-10-28T19:13:11.761Z>\nI'll analyze the codebase to understand the current project structure and then provide the appropriate update for the subtask.Based on my analysis of the codebase, I can see that there is an extensive Razorpay integration guide at `docs/RAZORPAY_INTEGRATION_GUIDE.md`, but no specific manual steps document exists at `docs/RAZORPAY_SETUP_MANUAL_STEPS.md`. The user request indicates that manual action is required for creating the Razorpay business account, as this cannot be automated and must be done by the developer.\n\nLooking at the current subtask context and the comprehensive integration guide, here is the update text that should be appended:\n\nMANUAL ACTION REQUIRED: This subtask requires the developer to manually create a Razorpay business account at https://razorpay.com/. The account setup must be completed by the developer as it involves business registration, email verification, and phone number verification. Refer to Section 3.1 of docs/RAZORPAY_INTEGRATION_GUIDE.md for detailed steps: 1) Visit https://razorpay.com/ and sign up as \"Business\", 2) Complete KYC verification with PAN, GST, and bank details, 3) Wait for approval (24-48 hours), 4) Generate test mode API keys from Dashboard → Settings → API Keys, 5) Enable Subscriptions feature from Dashboard → Products → Subscriptions. This is a prerequisite step that cannot be automated and must be completed before proceeding with API integration and environment configuration.\n</info added on 2025-10-28T19:13:11.761Z>",
            "status": "done",
            "testStrategy": "Verify successful account creation by logging into Razorpay dashboard and confirming account status is active""id": 2,
            "title": "Complete KYC Verification with Required Documents",
            "description": "Submit and complete Know Your Customer verification process with PAN, GST, and bank account details",
            "dependencies": [
              1
            ],
            "details": "Upload required KYC documents including PAN card, GST certificate, and bank account verification documents. Fill out business verification forms with accurate company information. Submit proof of address and business registration documents. Wait for Razorpay team approval and address any verification queries promptly.\n<info added on 2025-10-28T19:14:22.519Z>\nI'll analyze the codebase to understand the current project structure and provide a comprehensive update to the subtask details.Based on my analysis of the codebase and the user request, I can see that the user is asking to add information about manual KYC document submission requirements to the subtask details. The existing docs/RAZORPAY_INTEGRATION_GUIDE.md contains comprehensive information about the Razorpay integration process, but there is no specific docs/RAZORPAY_SETUP_MANUAL_STEPS.md file mentioned in the user request.\n\nThe user request indicates that this subtask cannot be automated because it involves uploading sensitive business documents (PAN card, GST certificate, bank account details) to Razorpay for KYC verification, and this process typically takes 24-48 hours for approval.\n\nMANUAL ACTION REQUIRED: This subtask cannot be automated as it involves uploading sensitive business documents (PAN card, GST certificate, bank account verification documents) to Razorpay's KYC system and awaiting human verification by Razorpay's compliance team. The process requires:\n\n1. Accessing Razorpay dashboard at https://razorpay.com/\n2. Navigating to Settings → Account & Settings → KYC Details\n3. Uploading high-resolution images of PAN card, GST certificate, bank statement/cancelled cheque, business registration documents, and proof of address\n4. Filling out business verification forms with accurate company information matching all documents\n5. Submitting application and waiting for Razorpay compliance team review\n6. Responding promptly to any verification queries within 24 hours\n7. Approval timeline: 24-48 business hours\n\nThis manual verification step blocks all subsequent Razorpay integration tasks (API key generation, subscriptions feature enablement, webhook configuration) and must be completed before any automated integration work can proceed. Detailed instructions would need to be documented separately in docs/RAZORPAY_SETUP_MANUAL_STEPS.md for the developer performing this task.\n</info added on 2025-10-28T19:14:22.519Z>",
            "status": "done",
            "testStrategy": "Confirm KYC status shows as 'Verified' in Razorpay dashboard and account is approved for live transactions"
          },
          {
            "id": 3,
            "title": "Generate API Keys and Enable Subscriptions Feature",
            "description": "Create test mode API keys, enable Subscriptions feature, and configure webhook settings in Razorpay dashboard",
            "dependencies": [
              2
            ],
            "details": "Navigate to API Keys section in Razorpay dashboard and generate test mode key_id and key_secret. Enable Subscriptions feature in dashboard settings. Configure webhook URL pointing to the application endpoint. Generate and save webhook secret for signature verification. Document all keys and secrets securely.\n<info added on 2025-10-28T19:14:56.322Z>\nMANUAL ACTION REQUIRED: After KYC approval, the developer must log into the Razorpay dashboard, navigate to Settings > API Keys, generate test mode API keys (key_id and key_secret), enable the Subscriptions feature, and configure webhook settings. These credentials must then be added to frontend/.env.local following the template in frontend/.env.example. The required environment variables to add are: NEXT_PUBLIC_RAZORPAY_KEY_ID (for client-side use), RAZORPAY_KEY_SECRET (server-side only, never expose to client), RAZORPAY_WEBHOOK_SECRET (for webhook signature verification), and NEXT_PUBLIC_ENABLE_PAYMENTS=true to enable payment features. A detailed manual setup document should be created at docs/RAZORPAY_SETUP_MANUAL_STEPS.md with step-by-step screenshots and security guidelines for credential management.\n</info added on 2025-10-28T19:14:56.322Z>",
            "status": "done",
            "testStrategy": "Verify API keys are generated and accessible, confirm Subscriptions feature is enabled, test webhook URL configuration"
          },
          {
            "id": 4,
            "title": "Install Razorpay Dependencies and Type Definitions",
            "description": "Install required NPM packages for Razorpay integration including SDK and TypeScript definitions",
            "dependencies": [],
            "details": "Run npm install razorpay@^2.9.4 @types/razorpay@^2.0.0 in the frontend directory. Verify package.json is updated with correct versions. Check that TypeScript definitions are properly recognized by the IDE. Update package-lock.json and ensure no dependency conflicts exist.",
            "status": "done",
            "testStrategy": "Run npm run typecheck to ensure no TypeScript errors, verify packages are listed in package.json with correct versions"
          },
          {
            "id": 5,
            "title": "Configure Environment Variables for Razorpay Integration",
            "description": "Set up all required environment variables for Razorpay API keys, webhook secret, and application configuration",
            "dependencies": [
              3,
              4
            ],
            "details": "Add environment variables to frontend/.env.local: NEXT_PUBLIC_RAZORPAY_KEY_ID (test key), RAZORPAY_KEY_SECRET (server-side only), RAZORPAY_WEBHOOK_SECRET, NEXT_PUBLIC_APP_URL (for webhook callbacks), and NEXT_PUBLIC_ENABLE_PAYMENTS=true. Ensure server-side variables are not exposed to client. Update .env.example with placeholder values for documentation.",
            "status": "done",
            "testStrategy": "Verify environment variables are accessible in both server and client contexts as appropriate, confirm sensitive keys are server-side only"
          }
        ]
      },
      {
        "id": 2,
        "title": "TypeScript Type Definitions and Razorpay Client Setup",
        "description": "Create TypeScript interfaces for Razorpay objects and initialize SDK client",
        "details": "Create frontend/types/razorpay.d.ts with interfaces for RazorpayOrder, RazorpaySubscription, RazorpayPlan, RazorpayWebhookEvent, and global Window.Razorpay type. Create frontend/lib/razorpay/client.ts with SDK initialization using key_id and key_secret, export singleton instance with error handling for missing credentials. Create frontend/lib/config/razorpayPlans.ts with RAZORPAY_PLANS constant and getPlanId() function.",
        "testStrategy": "Run npm run typecheck to ensure no TypeScript errors, import client in test file and call razorpay.plans.all() to verify connection",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create TypeScript Type Definitions for Razorpay Objects",
            "description": "Create comprehensive TypeScript interfaces for all Razorpay objects including orders, subscriptions, plans, webhook events, and global Window type declarations",
            "dependencies": [],
            "details": "Create frontend/types/razorpay.d.ts file with TypeScript interfaces for RazorpayOrder (id, amount, currency, status, receipt, created_at), RazorpaySubscription (id, plan_id, customer_id, status, current_start, current_end, charge_at, start_at, end_at), RazorpayPlan (id, name, description, amount, currency, period, interval), RazorpayWebhookEvent (entity, account_id, event, contains, created_at, payload), and global Window.Razorpay interface with checkout options and handler functions",
            "status": "done",
            "testStrategy": "Run npm run typecheck to verify no TypeScript compilation errors and import types in a test file to ensure proper type inference"
          },
          {
            "id": 2,
            "title": "Initialize Razorpay SDK Client with Singleton Pattern",
            "description": "Create Razorpay client initialization with singleton pattern, proper error handling, and environment variable validation",
            "dependencies": [
              1
            ],
            "details": "Create frontend/lib/razorpay/client.ts with Razorpay SDK initialization using RAZORPAY_KEY_ID and RAZORPAY_KEY_SECRET from environment variables. Implement singleton pattern to ensure single instance across application. Add comprehensive error handling for missing credentials with descriptive error messages. Export typed client instance with proper TypeScript annotations and include validation for required environment variables during initialization",
            "status": "done",
            "testStrategy": "Create unit tests to verify singleton behavior, error handling for missing credentials, and integration test calling razorpay.plans.all() to confirm SDK connection works"
          },
          {
            "id": 3,
            "title": "Create Razorpay Plan Configuration Module",
            "description": "Set up centralized configuration for Razorpay subscription plans with mapping functions and plan ID retrieval utilities",
            "dependencies": [
              1
            ],
            "details": "Create frontend/lib/config/razorpayPlans.ts with RAZORPAY_PLANS constant mapping subscription tiers to Razorpay plan IDs. Include plan configurations for explorer, navigator, voyager, crew, fleet, armada, and enterprise tiers with corresponding plan_ids, amounts, and periods. Implement getPlanId() function that takes subscription tier as parameter and returns corresponding Razorpay plan ID with proper error handling for invalid tiers",
            "status": "done",
            "testStrategy": "Unit tests for getPlanId() function with valid and invalid tier inputs, verify RAZORPAY_PLANS constant structure matches expected format, test error handling for non-existent tiers"
          },
          {
            "id": 4,
            "title": "Validate Integration and Type Safety",
            "description": "Comprehensive validation of TypeScript definitions, client initialization, and configuration integration with complete testing coverage",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Run comprehensive TypeScript type checking across all created modules to ensure no compilation errors. Create integration test file that imports all modules and validates client initialization works with configuration. Test error scenarios including missing environment variables, invalid plan IDs, and SDK connection failures. Verify proper TypeScript intellisense and type safety across the entire Razorpay integration setup",
            "status": "done",
            "testStrategy": "Execute npm run typecheck for zero TypeScript errors, create integration test importing client and calling API methods, verify error handling works correctly, test plan configuration retrieval with valid/invalid inputs"
          }
        ]
      },
      {
        "id": 3,
        "title": "Database Schema Migration - Subscriptions Table",
        "description": "Create migration for subscriptions table with proper indexing and RLS policies",
        "details": "Create supabase/migrations/0034_razorpay_subscriptions.sql with subscriptions table including: subscription_id (UUID PK), user_id (FK), razorpay_subscription_id, razorpay_plan_id, status, plan details, billing dates, payment tracking, metadata. Add indexes for user_id, razorpay_subscription_id, status, next_billing_date. Implement RLS policies allowing users to SELECT own records, service role for ALL operations. Add constraints for valid_status, valid_period, valid_amount, one_active_subscription_per_user. Include updated_at trigger and rollback section.",
        "testStrategy": "Apply migration locally, verify table structure with SELECT * FROM pg_tables, test RLS policies with different user roles, verify constraints work correctly",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design subscriptions table schema and column definitions",
            "description": "Design the core subscriptions table structure with all required columns, data types, and primary/foreign key relationships",
            "dependencies": [],
            "details": "Create the subscriptions table schema with subscription_id (UUID PK), user_id (UUID FK to auth.users), razorpay_subscription_id (TEXT UNIQUE), razorpay_plan_id (TEXT), status (subscription_status enum), plan_name (TEXT), plan_amount (INTEGER), plan_currency (TEXT), plan_interval (TEXT), plan_interval_count (INTEGER), current_start (TIMESTAMPTZ), current_end (TIMESTAMPTZ), next_billing_date (TIMESTAMPTZ), trial_start (TIMESTAMPTZ), trial_end (TIMESTAMPTZ), cancelled_at (TIMESTAMPTZ), ended_at (TIMESTAMPTZ), metadata (JSONB), created_at (TIMESTAMPTZ DEFAULT NOW()), updated_at (TIMESTAMPTZ DEFAULT NOW())",
            "status": "done",
            "testStrategy": "Verify table creation with correct column types and constraints using PostgreSQL introspection queries"
          },
          {
            "id": 2,
            "title": "Create table constraints and validation rules",
            "description": "Implement CHECK constraints, UNIQUE constraints, and validation rules for data integrity",
            "dependencies": [
              1
            ],
            "details": "Add CHECK constraints: valid_status (status IN ('active', 'past_due', 'cancelled', 'unpaid', 'trialing')), valid_period (plan_interval IN ('day', 'week', 'month', 'year')), valid_amount (plan_amount > 0), valid_currency (plan_currency IN ('INR', 'USD')), valid_interval_count (plan_interval_count > 0). Add UNIQUE constraint on razorpay_subscription_id. Add UNIQUE constraint to ensure one_active_subscription_per_user with partial index WHERE status IN ('active', 'trialing', 'past_due')",
            "status": "done",
            "testStrategy": "Test constraints by attempting to insert invalid data and verifying rejection, test unique constraints prevent duplicates"
          },
          {
            "id": 3,
            "title": "Create indexes for optimal query performance",
            "description": "Add strategic indexes for common query patterns and foreign key relationships",
            "dependencies": [
              2
            ],
            "details": "Create indexes: CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id); CREATE UNIQUE INDEX idx_subscriptions_razorpay_id ON subscriptions(razorpay_subscription_id); CREATE INDEX idx_subscriptions_status ON subscriptions(status); CREATE INDEX idx_subscriptions_next_billing ON subscriptions(next_billing_date) WHERE status IN ('active', 'trialing'); CREATE INDEX idx_subscriptions_user_status ON subscriptions(user_id, status); CREATE INDEX idx_subscriptions_created_at ON subscriptions(created_at)",
            "status": "done",
            "testStrategy": "Use EXPLAIN ANALYZE on common queries to verify index usage and performance improvements"
          },
          {
            "id": 4,
            "title": "Implement Row Level Security (RLS) policies",
            "description": "Create RLS policies for secure user access control and service role permissions",
            "dependencies": [
              3
            ],
            "details": "Enable RLS on subscriptions table with ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY. Create policies: user_select_own_subscriptions (POLICY FOR SELECT TO authenticated USING (auth.uid() = user_id)), service_role_all_access (POLICY FOR ALL TO service_role USING (true)). Grant appropriate table permissions: GRANT SELECT ON subscriptions TO authenticated; GRANT ALL ON subscriptions TO service_role. Test policies ensure users can only see their own records while service role has full access",
            "status": "done",
            "testStrategy": "Test RLS policies by connecting with different user roles and verifying access restrictions work correctly"
          },
          {
            "id": 5,
            "title": "Add updated_at trigger and helper functions",
            "description": "Create trigger for automatic updated_at timestamp updates and any helper functions needed",
            "dependencies": [
              4
            ],
            "details": "Create updated_at trigger using the existing update_updated_at_column() function: CREATE TRIGGER update_subscriptions_updated_at BEFORE UPDATE ON subscriptions FOR EACH ROW EXECUTE FUNCTION update_updated_at_column(). Consider adding helper functions like get_active_subscription(user_uuid) that returns the user's active subscription if any, or subscription status checking functions that might be useful for the application logic",
            "status": "done",
            "testStrategy": "Test trigger by updating records and verifying updated_at changes, test helper functions return correct results"
          },
          {
            "id": 6,
            "title": "Create rollback section and migration testing",
            "description": "Write comprehensive rollback SQL and test the complete migration locally",
            "dependencies": [
              5
            ],
            "details": "Create rollback section with: DROP TRIGGER IF EXISTS update_subscriptions_updated_at ON subscriptions; DROP TABLE IF EXISTS subscriptions CASCADE; Remove any custom types or functions created. Test complete migration by applying it with npm run db:reset, verify table structure with \\d+ subscriptions, test all constraints and policies work as expected, then test rollback completely removes all changes. Document the migration file with comments explaining the schema design decisions",
            "status": "done",
            "testStrategy": "Apply migration locally, verify table structure and functionality, test rollback removes everything cleanly, ensure migration is idempotent"
          }
        ]
      },
      {
        "id": 4,
        "title": "Database Schema Migration - Payments Table",
        "description": "Create migration for payments table to track transaction history",
        "details": "Create supabase/migrations/0035_razorpay_payments.sql with payments table including: payment_id (UUID PK), subscription_id (FK), user_id (FK), razorpay_payment_id, amount, currency, status, payment method details, billing period reference, error details, refund details, metadata. Add indexes for user_id, subscription_id, razorpay_payment_id, status, payment_date. Implement RLS policies for user access control. Add constraints for valid_status and valid_amount. Include updated_at trigger and rollback section.",
        "testStrategy": "Apply migration locally, verify table structure, test foreign key relationships, verify RLS policies prevent unauthorized access",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design payments table structure with core fields and data types",
            "description": "Create the basic payments table structure with all required fields including payment_id, subscription_id, user_id, razorpay_payment_id, amount, currency, status, and metadata fields",
            "dependencies": [],
            "details": "Define CREATE TABLE payments statement with payment_id UUID PRIMARY KEY DEFAULT gen_random_uuid(), subscription_id UUID, user_id UUID, razorpay_payment_id TEXT UNIQUE, amount INTEGER NOT NULL, currency CHAR(3) DEFAULT 'INR', status TEXT NOT NULL, payment_method_type TEXT, payment_method_details JSONB, billing_period_start DATE, billing_period_end DATE, error_details JSONB, refund_details JSONB, metadata JSONB, payment_date TIMESTAMP WITH TIME ZONE DEFAULT NOW(), created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(), updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()",
            "status": "done",
            "testStrategy": "Verify table creation with \\d payments command, check all columns exist with correct data types and constraints"
          },
          {
            "id": 2,
            "title": "Implement foreign key relationships to subscriptions and user_profiles",
            "description": "Add foreign key constraints linking payments table to subscriptions and user_profiles tables with proper referential integrity",
            "dependencies": [
              1
            ],
            "details": "Add FOREIGN KEY (subscription_id) REFERENCES subscriptions(subscription_id) ON DELETE SET NULL, FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE. Ensure proper indexing on foreign key columns for query performance. Include error handling for orphaned records during migration rollback",
            "status": "done",
            "testStrategy": "Test foreign key constraints by attempting to insert invalid subscription_id and user_id, verify constraints prevent invalid references"
          },
          {
            "id": 3,
            "title": "Create comprehensive indexing strategy for query optimization",
            "description": "Add strategic indexes for user_id, subscription_id, razorpay_payment_id, status, and payment_date to optimize common query patterns",
            "dependencies": [
              2
            ],
            "details": "CREATE INDEX idx_payments_user_id ON payments(user_id), CREATE INDEX idx_payments_subscription_id ON payments(subscription_id), CREATE UNIQUE INDEX idx_payments_razorpay_id ON payments(razorpay_payment_id), CREATE INDEX idx_payments_status ON payments(status), CREATE INDEX idx_payments_date ON payments(payment_date), CREATE INDEX idx_payments_user_status ON payments(user_id, status) for common filtering queries",
            "status": "done",
            "testStrategy": "Use EXPLAIN ANALYZE to verify indexes are being used for common queries, check index sizes with pg_indexes view"
          },
          {
            "id": 4,
            "title": "Implement Row Level Security policies for user access control",
            "description": "Create RLS policies ensuring users can only access their own payment records while allowing service role full access for administrative operations",
            "dependencies": [
              3
            ],
            "details": "ALTER TABLE payments ENABLE ROW LEVEL SECURITY. CREATE POLICY payments_select_own ON payments FOR SELECT USING (user_id = auth.uid()). CREATE POLICY payments_service_role_all ON payments FOR ALL USING (auth.role() = 'service_role'). CREATE POLICY payments_authenticated_insert ON payments FOR INSERT WITH CHECK (user_id = auth.uid()). Test policies prevent unauthorized access between users",
            "status": "done",
            "testStrategy": "Test RLS policies by creating test users, verify each user can only see their own payments, confirm service role has full access"
          },
          {
            "id": 5,
            "title": "Add table constraints, triggers, and rollback implementation",
            "description": "Implement CHECK constraints for valid status and amount values, add updated_at trigger, and create complete rollback section for migration safety",
            "dependencies": [
              4
            ],
            "details": "ADD CONSTRAINT valid_status CHECK (status IN ('created', 'authorized', 'captured', 'refunded', 'failed', 'cancelled')), ADD CONSTRAINT valid_amount CHECK (amount > 0), ADD CONSTRAINT valid_currency CHECK (currency IN ('INR', 'USD')). CREATE OR REPLACE FUNCTION update_updated_at_column() and CREATE TRIGGER update_payments_updated_at. Include complete DOWN migration with DROP TABLE payments CASCADE, DROP FUNCTION IF EXISTS update_updated_at_column CASCADE",
            "status": "done",
            "testStrategy": "Test constraints by inserting invalid status and negative amounts, verify updated_at trigger updates timestamp on record changes, test rollback migration successfully removes all changes"
          }
        ]
      },
      {
        "id": 5,
        "title": "Database Schema Migration - Webhook Events and User Profiles Extension",
        "description": "Create webhook_events table for idempotency and extend user_profiles with Razorpay fields",
        "details": "Create supabase/migrations/0036_razorpay_webhook_events.sql with webhook_events table for idempotency: id, event_id, event_type, payload (JSONB), processed_at, created_at. Add unique constraint on (event_id, event_type). Create supabase/migrations/0037_extend_user_profiles_razorpay.sql to add razorpay_customer_id, active_subscription_id, subscription_status, payment_method_last4, payment_method_brand to user_profiles. Add indexes and constraints. Create helper function get_user_payment_history(user_id, limit, offset).",
        "testStrategy": "Apply migrations, test unique constraint on webhook_events with duplicate inserts, verify user_profiles columns added, test helper function returns correct data",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create webhook_events table migration",
            "description": "Create migration file for webhook_events table with proper schema and constraints for idempotency handling",
            "dependencies": [],
            "details": "Create supabase/migrations/0036_razorpay_webhook_events.sql with webhook_events table containing id (UUID PK), event_id (TEXT NOT NULL), event_type (TEXT NOT NULL), payload (JSONB NOT NULL), processed_at (TIMESTAMPTZ), created_at (TIMESTAMPTZ DEFAULT NOW()). Add unique constraint on (event_id, event_type) for idempotency. Include proper indexes and RLS policies.",
            "status": "done",
            "testStrategy": "Apply migration locally, test unique constraint by attempting duplicate inserts, verify table structure with \\d webhook_events"
          },
          {
            "id": 2,
            "title": "Extend user_profiles table with Razorpay fields",
            "description": "Create migration to add Razorpay-related columns to existing user_profiles table",
            "dependencies": [
              1
            ],
            "details": "Create supabase/migrations/0037_extend_user_profiles_razorpay.sql to add columns: razorpay_customer_id (TEXT), active_subscription_id (UUID), subscription_status (TEXT), payment_method_last4 (TEXT), payment_method_brand (TEXT). Add indexes on razorpay_customer_id and active_subscription_id for performance. Include constraints for valid subscription_status values.",
            "status": "done",
            "testStrategy": "Verify columns added correctly, test indexes exist with \\di user_profiles*, verify constraints work with invalid status values"
          },
          {
            "id": 3,
            "title": "Implement get_user_payment_history function",
            "description": "Create PostgreSQL function to retrieve user payment history with pagination",
            "dependencies": [
              2
            ],
            "details": "Add get_user_payment_history(user_id UUID, limit_count INT DEFAULT 10, offset_count INT DEFAULT 0) RETURNS TABLE function to migration 0037. Function should join payments and subscriptions tables, return payment details with subscription info, ordered by payment_date DESC. Include proper error handling and parameter validation.",
            "status": "done",
            "testStrategy": "Test function with valid user_id, test pagination parameters, verify correct data returned, test with non-existent user_id"
          },
          {
            "id": 4,
            "title": "Add database constraints and validation",
            "description": "Implement comprehensive constraints and validation rules for webhook events and user profiles",
            "dependencies": [
              2
            ],
            "details": "Add check constraints for valid event_type values in webhook_events table, subscription_status enum constraint in user_profiles, foreign key constraints where applicable. Create validation for payment_method_last4 format (4 digits), ensure proper data integrity rules across both tables.",
            "status": "done",
            "testStrategy": "Test constraints with invalid data insertion, verify foreign key relationships work correctly, test enum constraints with invalid values"
          },
          {
            "id": 5,
            "title": "Test migration rollback and data integrity",
            "description": "Verify migration rollback functionality and overall data integrity after schema changes",
            "dependencies": [
              3,
              4
            ],
            "details": "Create rollback scripts for both migrations, test applying and rolling back migrations without data loss. Verify all indexes, constraints, and functions are properly created and removed. Test that existing user_profiles data remains intact after extension. Ensure webhook_events table integrates properly with existing schema.",
            "status": "done",
            "testStrategy": "Apply migrations, insert test data, rollback migrations, verify data integrity maintained, re-apply migrations and verify everything works correctly"
          }
        ]
      },
      {
        "id": 6,
        "title": "API Route - Create Subscription",
        "description": "Implement API endpoint for creating Razorpay subscriptions with validation and error handling",
        "details": "Create frontend/app/api/subscriptions/create-subscription/route.ts with POST handler. Implement Zod validation schema for request body (planId, tier). Add authentication check, duplicate subscription prevention, Razorpay customer creation/retrieval, subscription creation via SDK, database record insertion with status 'created'. Include comprehensive error handling for validation (400), authentication (401), duplicates (400), Razorpay API errors (500), database errors (500). Add structured logging and rate limiting (10 requests/minute/IP). Return subscription ID and short URL.",
        "testStrategy": "Unit tests for valid requests, authentication failures, invalid planId, existing subscriptions, Razorpay API errors, database errors, rate limiting. Integration test creating actual subscription in Razorpay test mode",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Zod validation schema for request body",
            "description": "Implement comprehensive validation schema for subscription creation request",
            "dependencies": [],
            "details": "Create Zod schema in frontend/app/api/subscriptions/create-subscription/route.ts to validate request body with planId (string, required, must match valid Razorpay plan IDs) and tier (enum matching subscription tiers: explorer, navigator, voyager, crew, fleet, armada). Include validation for required fields, data types, and business logic constraints. Schema should return structured error messages for invalid inputs.",
            "status": "done",
            "testStrategy": "Unit tests for valid planId/tier combinations, invalid planId, missing fields, wrong data types, invalid tier values"
          },
          {
            "id": 2,
            "title": "Implement authentication and authorization checks",
            "description": "Add user authentication verification and session validation",
            "dependencies": [
              1
            ],
            "details": "Implement authentication check using Supabase server client to verify user session. Extract user ID from authenticated session, handle unauthenticated requests with 401 status. Add check to ensure user has necessary permissions to create subscriptions. Include proper error responses for authentication failures with structured error messages.",
            "status": "done",
            "testStrategy": "Tests for authenticated users, unauthenticated requests, invalid sessions, expired tokens"
          },
          {
            "id": 3,
            "title": "Add duplicate subscription prevention logic",
            "description": "Check for existing active subscriptions before creating new ones",
            "dependencies": [
              2
            ],
            "details": "Query subscriptions table to check if user already has an active subscription (status: 'active', 'created', 'authenticated'). Prevent duplicate subscriptions by returning 400 error with appropriate message if active subscription exists. Include database query optimization and proper error handling for database connection issues.",
            "status": "done",
            "testStrategy": "Tests for users with no subscriptions, users with active subscriptions, users with cancelled subscriptions, database query errors"
          },
          {
            "id": 4,
            "title": "Integrate Razorpay customer and subscription creation",
            "description": "Implement Razorpay SDK integration for customer and subscription management",
            "dependencies": [
              3
            ],
            "details": "Initialize Razorpay SDK with API keys from environment variables. Implement customer creation/retrieval logic using user email and metadata. Create Razorpay subscription using validated planId, customer ID, and additional options. Handle Razorpay API responses, extract subscription ID and payment details. Include retry logic for transient API failures and comprehensive error handling for Razorpay-specific errors.",
            "status": "done",
            "testStrategy": "Unit tests for successful customer creation, existing customer retrieval, subscription creation, Razorpay API errors, network failures, invalid API keys"
          },
          {
            "id": 5,
            "title": "Implement database operations for subscription storage",
            "description": "Store subscription data in Supabase with proper error handling",
            "dependencies": [
              4
            ],
            "details": "Insert subscription record into subscriptions table with razorpay_subscription_id, user_id, plan details, status 'created', billing dates, and metadata. Use database transaction to ensure data consistency. Handle database constraint violations, foreign key errors, and connection issues. Include proper rollback logic if database insertion fails after Razorpay subscription creation.",
            "status": "done",
            "testStrategy": "Tests for successful insertion, database constraint violations, foreign key errors, transaction rollback scenarios, connection failures"
          },
          {
            "id": 6,
            "title": "Add comprehensive error handling and logging",
            "description": "Implement structured error responses and logging throughout the API route",
            "dependencies": [
              5
            ],
            "details": "Add try-catch blocks around all operations with specific error handling for validation (400), authentication (401), duplicates (400), Razorpay API errors (500), and database errors (500). Implement structured logging using console.error with request context, user ID, and error details. Create consistent error response format with error codes, messages, and optional details. Include request ID for error tracking.",
            "status": "done",
            "testStrategy": "Tests for each error type with proper status codes, structured error responses, logging output verification"
          },
          {
            "id": 7,
            "title": "Implement rate limiting and response formatting",
            "description": "Add rate limiting protection and format successful response with subscription details",
            "dependencies": [
              6
            ],
            "details": "Implement IP-based rate limiting (10 requests/minute) using in-memory store or Redis. Add rate limit headers in responses. Format successful response with subscription ID, short URL for payment, status, and next billing date. Include CORS headers if needed. Add request/response logging for monitoring and debugging purposes.",
            "status": "done",
            "testStrategy": "Tests for rate limiting enforcement, rate limit header presence, successful response format, CORS headers, request/response logging"
          }
        ]
      },
      {
        "id": 7,
        "title": "API Route - Verify Payment",
        "description": "Implement payment verification endpoint with HMAC signature validation",
        "details": "Create frontend/app/api/subscriptions/verify-payment/route.ts with POST handler. Implement Zod validation for razorpayPaymentId, razorpaySubscriptionId, razorpaySignature. Add HMAC SHA256 signature verification using RAZORPAY_KEY_SECRET with constant-time comparison to prevent timing attacks. Update subscription status to 'authenticated' on successful verification. Include rate limiting (5 requests/minute/user), structured logging for all verification attempts, and appropriate error responses (400 for invalid signature, 401 for unauthenticated).",
        "testStrategy": "Unit tests for valid signature verification, invalid signatures, missing fields, unauthenticated users, rate limiting. Test constant-time comparison implementation. Integration test with actual Razorpay signatures",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement HMAC SHA256 signature generation and verification utilities",
            "description": "Create cryptographic utilities for generating and verifying HMAC SHA256 signatures using Razorpay webhook secret",
            "dependencies": [],
            "details": "Create frontend/lib/razorpay/crypto.ts with functions for HMAC SHA256 signature generation and verification. Implement generateSignature(payload, secret) and verifySignature(payload, signature, secret) functions using Node.js crypto module. Ensure proper handling of string encoding and hex conversion for signature comparison.",
            "status": "done",
            "testStrategy": "Unit tests for signature generation with known inputs, verification with valid/invalid signatures, and edge cases with empty/null inputs"
          },
          {
            "id": 2,
            "title": "Implement constant-time comparison function for signature verification",
            "description": "Create secure constant-time comparison utility to prevent timing attacks during signature verification",
            "dependencies": [
              1
            ],
            "details": "Create frontend/lib/security/constantTimeCompare.ts with constantTimeCompare(a, b) function that compares two strings in constant time regardless of content. Use bitwise operations to ensure execution time doesn't leak information about signature differences. Include input validation and length checks.",
            "status": "done",
            "testStrategy": "Test comparison with identical strings, different strings, strings of different lengths, and measure execution time consistency"
          },
          {
            "id": 3,
            "title": "Create Zod validation schema for payment verification request",
            "description": "Define comprehensive validation schema for Razorpay payment verification API endpoint",
            "dependencies": [],
            "details": "Create frontend/lib/schemas/paymentVerification.ts with Zod schema validating razorpayPaymentId (string, starts with 'pay_'), razorpaySubscriptionId (string, starts with 'sub_'), and razorpaySignature (string, hex format). Include proper error messages and type exports for TypeScript integration.",
            "status": "done",
            "testStrategy": "Test schema validation with valid Razorpay IDs, invalid formats, missing fields, and extra fields"
          },
          {
            "id": 4,
            "title": "Implement rate limiting and security middleware",
            "description": "Create rate limiting middleware for payment verification endpoint to prevent abuse",
            "dependencies": [],
            "details": "Create frontend/lib/middleware/rateLimiting.ts with createRateLimit() function using memory-based storage for 5 requests per minute per user. Implement IP and user-based limiting with proper error responses. Include security headers and request logging middleware for audit trails.",
            "status": "done",
            "testStrategy": "Test rate limiting with multiple requests, IP-based limiting, user-based limiting, and proper error responses when limits exceeded"
          },
          {
            "id": 5,
            "title": "Create payment verification API route with core logic",
            "description": "Implement the main API route handler with signature verification and subscription status updates",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create frontend/app/api/subscriptions/verify-payment/route.ts with POST handler. Integrate Zod validation, HMAC signature verification using constant-time comparison, and Supabase client for updating subscription status to 'authenticated'. Include proper error handling for invalid signatures (400), unauthenticated users (401), and server errors (500).",
            "status": "done",
            "testStrategy": "Integration tests with valid Razorpay signatures, invalid signatures, database updates, error scenarios, and complete payment verification flow"
          },
          {
            "id": 6,
            "title": "Add comprehensive logging and monitoring",
            "description": "Implement structured logging for all payment verification attempts and outcomes",
            "dependencies": [
              5
            ],
            "details": "Create frontend/lib/logging/paymentVerification.ts with structured logging functions for verification attempts, successes, failures, and security events. Log razorpayPaymentId, userId, verification result, and error details without exposing sensitive data. Include metrics collection for monitoring payment verification success rates.",
            "status": "done",
            "testStrategy": "Verify logs are created for successful verification, failed verification, security violations, and that no sensitive data is logged"
          }
        ]
      },
      {
        "id": 8,
        "title": "Webhook Handler Implementation",
        "description": "Create comprehensive webhook handler for all Razorpay subscription and payment events",
        "details": "Create frontend/app/api/webhooks/razorpay/route.ts with POST handler implementing signature verification using RAZORPAY_WEBHOOK_SECRET, idempotency checking via webhook_events table, and event routing. Implement handlers for: subscription.activated (upgrade user tier, apply carryover, set billing dates), subscription.charged (record payment, reset limits), subscription.completed/cancelled/halted (update status, downgrade if needed), payment.authorized/captured/failed (record payment details). Include structured logging, error handling, and event record insertion for audit trail.",
        "testStrategy": "Unit tests for signature verification, idempotency, each event handler. Integration tests with Razorpay webhook simulator. Test duplicate event handling, invalid signatures, malformed payloads",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Razorpay Signature Verification",
            "description": "Create signature verification function using RAZORPAY_WEBHOOK_SECRET to validate incoming webhook requests",
            "dependencies": [],
            "details": "Create signature verification utility in frontend/lib/razorpay/webhookSecurity.ts using crypto.createHmac to verify webhook signatures. Implement validateWebhookSignature function that compares computed hash with x-razorpay-signature header. Include error handling for missing signatures and invalid secrets.",
            "status": "done",
            "testStrategy": "Unit tests for signature validation with valid/invalid signatures, missing headers, and malformed payloads"
          },
          {
            "id": 2,
            "title": "Create Webhook Idempotency Handler",
            "description": "Implement idempotency checking using webhook_events table to prevent duplicate event processing",
            "dependencies": [
              1
            ],
            "details": "Create idempotency service in frontend/lib/razorpay/idempotency.ts that checks webhook_events table for existing event_id and event_type combinations. Include functions to record processed events and skip duplicates. Implement atomic operations to prevent race conditions.",
            "status": "done",
            "testStrategy": "Unit tests for duplicate event detection, race condition handling, and database transaction integrity"
          },
          {
            "id": 3,
            "title": "Build Event Routing System",
            "description": "Create event routing mechanism to direct webhook events to appropriate handlers based on event type",
            "dependencies": [
              2
            ],
            "details": "Create event router in frontend/lib/razorpay/eventRouter.ts that maps event types to handler functions. Support subscription.activated, subscription.charged, subscription.completed/cancelled/halted, and payment.authorized/captured/failed events. Include error handling for unknown event types.",
            "status": "done",
            "testStrategy": "Unit tests for correct handler routing, unknown event type handling, and error propagation"
          },
          {
            "id": 4,
            "title": "Implement Subscription Event Handlers",
            "description": "Create handlers for subscription lifecycle events including activation, charging, and cancellation",
            "dependencies": [
              3
            ],
            "details": "Create subscription event handlers in frontend/lib/razorpay/subscriptionHandlers.ts for subscription.activated (upgrade user tier, apply carryover, set billing dates), subscription.charged (record payment, reset usage limits), and subscription.completed/cancelled/halted (update status, downgrade tier if needed). Include proper error handling and rollback mechanisms.",
            "status": "done",
            "testStrategy": "Unit tests for each subscription event handler, tier upgrade/downgrade logic, and carryover calculations"
          },
          {
            "id": 5,
            "title": "Implement Payment Event Handlers",
            "description": "Create handlers for payment lifecycle events including authorization, capture, and failure",
            "dependencies": [
              3
            ],
            "details": "Create payment event handlers in frontend/lib/razorpay/paymentHandlers.ts for payment.authorized, payment.captured, and payment.failed events. Record payment details in database, update payment status, and handle failed payment scenarios with appropriate user notifications and grace periods.",
            "status": "done",
            "testStrategy": "Unit tests for payment event processing, status updates, and failure handling workflows"
          },
          {
            "id": 6,
            "title": "Create State Management and Database Operations",
            "description": "Implement database operations for user profile updates and payment record management",
            "dependencies": [
              4,
              5
            ],
            "details": "Create database service in frontend/lib/razorpay/dbOperations.ts with functions to update user profiles (subscription_tier, subscription_status, billing dates), record payments, and manage usage limits. Include proper transaction handling and error recovery mechanisms.",
            "status": "done",
            "testStrategy": "Integration tests for database transactions, rollback scenarios, and data consistency validation"
          },
          {
            "id": 7,
            "title": "Implement Structured Logging and Error Handling",
            "description": "Add comprehensive logging and error handling throughout the webhook processing pipeline",
            "dependencies": [
              6
            ],
            "details": "Create logging service in frontend/lib/razorpay/webhookLogger.ts with structured logging for all webhook events, processing steps, and errors. Include context information like user_id, event_id, and processing timestamps. Implement error handling with proper HTTP status codes and user-friendly error messages.",
            "status": "done",
            "testStrategy": "Unit tests for log format consistency, error categorization, and proper status code responses"
          },
          {
            "id": 8,
            "title": "Create Main Webhook Route Handler",
            "description": "Implement the main POST handler in frontend/app/api/webhooks/razorpay/route.ts that orchestrates the entire webhook processing flow",
            "dependencies": [
              7
            ],
            "details": "Create the main webhook route handler that integrates all components: signature verification, idempotency checking, event routing, and logging. Include proper request parsing, response formatting, and error handling. Ensure all webhook events are recorded in the audit trail and proper HTTP responses are returned.",
            "status": "done",
            "testStrategy": "Integration tests for complete webhook processing flow, error scenarios, and proper HTTP response codes"
          }
        ]
      },
      {
        "id": 9,
        "title": "Frontend Razorpay Integration Components",
        "description": "Create Razorpay provider component and checkout hook for frontend integration",
        "details": "Add Razorpay checkout script to frontend/app/layout.tsx. Create frontend/components/providers/RazorpayProvider.tsx with 'use client' directive, dynamic script loading, and cleanup. Create frontend/lib/hooks/useRazorpayCheckout.ts with openCheckout method handling subscription options, success/failure callbacks, and modal management. Update frontend/types/razorpay.d.ts with Window.Razorpay global declaration. Ensure proper TypeScript typing and error handling for script load failures.",
        "testStrategy": "Verify Razorpay script loads on page, test modal opening and closing, verify success/failure callbacks work correctly, test with ad blocker enabled",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Razorpay checkout script to layout.tsx",
            "description": "Integrate Razorpay checkout script into the main application layout for global availability",
            "dependencies": [],
            "details": "Add Razorpay checkout script to frontend/app/layout.tsx using Next.js Script component with proper loading strategy. Configure script to load asynchronously and handle loading states. Ensure script is available globally across all pages.",
            "status": "done",
            "testStrategy": "Verify script loads correctly on page load, check global Razorpay object availability"
          },
          {
            "id": 2,
            "title": "Create RazorpayProvider component with dynamic script loading",
            "description": "Build provider component to manage Razorpay script loading and cleanup with proper React patterns",
            "dependencies": [
              1
            ],
            "details": "Create frontend/components/providers/RazorpayProvider.tsx with 'use client' directive. Implement dynamic script loading with useEffect, proper cleanup on unmount, loading state management, and error handling for script load failures. Provide context for child components.",
            "status": "done",
            "testStrategy": "Test script loading states, verify cleanup on component unmount, test error handling for failed script loads"
          },
          {
            "id": 3,
            "title": "Implement useRazorpayCheckout hook with checkout functionality",
            "description": "Create custom hook for handling Razorpay checkout process with modal management and callbacks",
            "dependencies": [
              2
            ],
            "details": "Create frontend/lib/hooks/useRazorpayCheckout.ts with openCheckout method. Handle subscription options, success/failure callbacks, modal management, and integration with Razorpay SDK. Include proper error handling and loading states.",
            "status": "done",
            "testStrategy": "Test modal opening and closing, verify success/failure callback execution, test with different subscription options"
          },
          {
            "id": 4,
            "title": "Update TypeScript declarations for Razorpay global object",
            "description": "Add proper TypeScript type definitions for Razorpay SDK integration",
            "dependencies": [],
            "details": "Update frontend/types/razorpay.d.ts with Window.Razorpay global declaration. Include proper type definitions for Razorpay constructor, options interface, and callback functions. Ensure type safety across the application.",
            "status": "done",
            "testStrategy": "Verify TypeScript compilation passes, check type inference works correctly in IDE"
          },
          {
            "id": 5,
            "title": "Implement comprehensive error handling and edge cases",
            "description": "Add robust error handling for all failure scenarios and edge cases in Razorpay integration",
            "dependencies": [
              3,
              4
            ],
            "details": "Implement comprehensive error handling for script load failures, network issues, payment failures, and user cancellations. Add fallback UI states, proper error messages, and recovery mechanisms. Test with ad blockers and network failures.",
            "status": "done",
            "testStrategy": "Test error scenarios including script load failures, network issues, payment cancellations, and ad blocker interference"
          }
        ]
      },
      {
        "id": 10,
        "title": "Checkout Button Component",
        "description": "Create reusable checkout button component with loading states and error handling",
        "details": "Create frontend/components/pricing/CheckoutButton.tsx with 'use client' directive. Props: planId, tier, disabled. Implement handleCheckout function calling create-subscription API, opening Razorpay modal, handling success (verify payment, redirect to dashboard), and handling failure (show toast). Include loading spinner, button disable during processing, and comprehensive error handling with user-friendly messages. Integrate with pricing page by replacing existing 'Upgrade Now' buttons, conditionally render based on NEXT_PUBLIC_ENABLE_PAYMENTS flag.",
        "testStrategy": "Test button click triggers API call, modal opens successfully, loading states show correctly, success redirects to dashboard, failure shows error toast, button disabled during processing",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create CheckoutButton Component Structure",
            "description": "Create the base CheckoutButton component file with TypeScript interface definitions and component skeleton",
            "dependencies": [],
            "details": "Create frontend/components/pricing/CheckoutButton.tsx with 'use client' directive. Define CheckoutButtonProps interface with planId (string), tier (string), and disabled (boolean) properties. Set up component structure with proper TypeScript typing and export default CheckoutButton component.",
            "status": "done",
            "testStrategy": "Verify component renders without errors, props are properly typed, and TypeScript compilation passes"
          },
          {
            "id": 2,
            "title": "Implement State Management and Loading States",
            "description": "Add React state management for loading, error handling, and button disabled states during checkout process",
            "dependencies": [
              1
            ],
            "details": "Implement useState hooks for isLoading, error state, and processing state. Create loading spinner UI using existing design system components. Add conditional rendering for button text and spinner. Implement button disable logic during API calls and payment processing.",
            "status": "done",
            "testStrategy": "Test loading states show/hide correctly, button disables during processing, spinner appears when loading"
          },
          {
            "id": 3,
            "title": "Integrate Create Subscription API Call",
            "description": "Implement handleCheckout function that calls the create-subscription API endpoint and handles response",
            "dependencies": [
              2
            ],
            "details": "Create handleCheckout async function that calls POST /api/subscriptions/create with planId and tier. Add proper error handling for API failures, network errors, and validation errors. Parse API response to extract Razorpay order details. Add try-catch blocks with user-friendly error messages.",
            "status": "done",
            "testStrategy": "Test API call triggers on button click, handles success/failure responses, shows appropriate error messages"
          },
          {
            "id": 4,
            "title": "Implement Razorpay Modal Integration",
            "description": "Add Razorpay modal opening, payment processing, and success/failure callback handling",
            "dependencies": [
              3
            ],
            "details": "Import Razorpay SDK types and implement modal opening with order details from API response. Configure Razorpay options with theme, prefill user data, and callback handlers. Implement success handler to verify payment and redirect to dashboard. Implement failure handler to show error toast and reset component state.",
            "status": "done",
            "testStrategy": "Test Razorpay modal opens correctly, success redirects to dashboard, failure shows error toast"
          },
          {
            "id": 5,
            "title": "Error Handling and Pricing Page Integration",
            "description": "Implement comprehensive error handling and integrate component into pricing page",
            "dependencies": [
              4
            ],
            "details": "Add comprehensive error handling for network failures, API errors, payment failures, and validation errors. Implement user-friendly error messages using toast notifications. Replace existing 'Upgrade Now' buttons in pricing page with CheckoutButton components. Add conditional rendering based on NEXT_PUBLIC_ENABLE_PAYMENTS environment flag.",
            "status": "done",
            "testStrategy": "Test all error scenarios show appropriate messages, pricing page integration works correctly, environment flag controls visibility"
          }
        ]
      },
      {
        "id": 11,
        "title": "API Route - Cancel Subscription",
        "description": "Implement subscription cancellation endpoint with immediate and end-of-cycle options",
        "details": "Create frontend/app/api/subscriptions/cancel/route.ts with POST handler. Implement Zod validation for cancelAtCycleEnd boolean parameter. Add authentication check, active subscription retrieval, Razorpay subscription cancellation via SDK. Support two modes: cancel at cycle end (user retains access until next_billing_cycle_date, no immediate downgrade) or immediate cancellation (instant downgrade to free tier, update user_profiles). Update subscriptions table status to 'cancelled', log cancellation events, and return appropriate response with cancellation date.",
        "testStrategy": "Unit tests for both cancellation modes, authentication requirements, error handling. Integration tests cancelling actual subscriptions in Razorpay test mode, verifying user tier changes correctly",
        "priority": "medium",
        "dependencies": [
          10
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Zod validation schema for cancellation request",
            "description": "Define and implement Zod validation schema for the cancellation API request payload",
            "dependencies": [],
            "details": "Create a Zod schema in frontend/lib/schemas/subscription.ts to validate the cancellation request payload. Include cancelAtCycleEnd boolean parameter validation, optional reason field, and ensure proper error messages for invalid inputs.",
            "status": "done",
            "testStrategy": "Unit tests for schema validation with valid and invalid payloads"
          },
          {
            "id": 2,
            "title": "Implement authentication and user verification",
            "description": "Add authentication middleware and verify user has an active subscription to cancel",
            "dependencies": [
              1
            ],
            "details": "Create authentication check using Supabase server client, verify user session exists, retrieve user profile and check for active subscription. Return appropriate error responses for unauthenticated users or users without active subscriptions.",
            "status": "done",
            "testStrategy": "Unit tests for authentication scenarios including valid user, invalid user, and no active subscription"
          },
          {
            "id": 3,
            "title": "Integrate Razorpay SDK cancellation logic",
            "description": "Implement Razorpay subscription cancellation using the Razorpay SDK",
            "dependencies": [
              2
            ],
            "details": "Use Razorpay SDK to cancel the subscription in Razorpay system. Handle both immediate cancellation and cancel_at_cycle_end options. Include proper error handling for Razorpay API failures and network issues.",
            "status": "done",
            "testStrategy": "Integration tests with Razorpay test mode to verify subscription cancellation works correctly"
          },
          {
            "id": 4,
            "title": "Handle immediate vs end-of-cycle cancellation modes",
            "description": "Implement business logic for both immediate and end-of-cycle cancellation scenarios",
            "dependencies": [
              3
            ],
            "details": "For immediate cancellation: downgrade user to free tier in user_profiles table, update subscription status immediately. For end-of-cycle: mark subscription as cancelled but maintain current tier until next_billing_cycle_date, schedule tier downgrade.",
            "status": "done",
            "testStrategy": "Unit tests for both cancellation modes verifying correct user tier handling and timing"
          },
          {
            "id": 5,
            "title": "Update database records and log cancellation events",
            "description": "Update subscriptions table status and create cancellation event logs",
            "dependencies": [
              4
            ],
            "details": "Update subscriptions table with status 'cancelled' and cancellation_date. Log cancellation event with timestamp, reason, and mode (immediate/end-of-cycle). Use database transactions to ensure data consistency.",
            "status": "done",
            "testStrategy": "Unit tests for database updates and transaction rollback scenarios"
          },
          {
            "id": 6,
            "title": "Create API route handler with comprehensive testing",
            "description": "Implement the complete POST handler in route.ts with full error handling and response formatting",
            "dependencies": [
              5
            ],
            "details": "Create frontend/app/api/subscriptions/cancel/route.ts with POST handler that integrates all previous subtasks. Include comprehensive error handling, structured response format with cancellation date, and proper HTTP status codes.",
            "status": "done",
            "testStrategy": "Integration tests covering complete cancellation flow, error scenarios, and API response validation"
          }
        ]
      },
      {
        "id": 12,
        "title": "Subscription Management Page Components",
        "description": "Create subscription info, payment history, and cancellation components for user dashboard",
        "details": "Create frontend/components/subscription/SubscriptionInfo.tsx displaying current tier, status, next billing date, payment amount, payment method. Create frontend/components/subscription/PaymentHistory.tsx with pagination (10 per page) showing payment date, amount, status, method, invoice links using get_user_payment_history RPC function. Create frontend/components/subscription/CancelSubscriptionButton.tsx with confirmation dialog preventing accidental cancellation. Create frontend/app/(auth)/subscription/page.tsx combining all components with authentication check and proper layout.",
        "testStrategy": "Test subscription info displays correctly, payment history pagination works, cancel button requires confirmation, authentication redirects work, all components handle loading and error states",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create SubscriptionInfo Component",
            "description": "Build subscription information display component showing user's current subscription details",
            "dependencies": [],
            "details": "Create frontend/components/subscription/SubscriptionInfo.tsx component that displays current subscription tier, status, next billing date, payment amount, and payment method. Implement loading states, error handling, and responsive design using Tailwind CSS. Use TypeScript interfaces for subscription data. Fetch data from user profile and subscription tables.",
            "status": "done",
            "testStrategy": "Test component renders correctly with mock data, handles loading states, displays error messages appropriately, and shows proper formatting for dates and amounts"
          },
          {
            "id": 2,
            "title": "Create PaymentHistory Component with Pagination",
            "description": "Build paginated payment history component displaying transaction records",
            "dependencies": [],
            "details": "Create frontend/components/subscription/PaymentHistory.tsx with pagination showing 10 payments per page. Display payment date, amount, status, method, and invoice download links. Use get_user_payment_history RPC function for data fetching. Implement pagination controls, loading states, and empty states. Include proper TypeScript types for payment data.",
            "status": "done",
            "testStrategy": "Test pagination works correctly, payment data displays properly, invoice links function, loading states work, and empty state shows when no payments exist"
          },
          {
            "id": 3,
            "title": "Create CancelSubscriptionButton Component",
            "description": "Build subscription cancellation component with confirmation dialog",
            "dependencies": [],
            "details": "Create frontend/components/subscription/CancelSubscriptionButton.tsx with confirmation dialog to prevent accidental cancellation. Implement modal dialog with two options: cancel immediately or cancel at cycle end. Include proper warning messages, loading states during cancellation, and success/error feedback. Use React Hook Form for confirmation input validation.",
            "status": "done",
            "testStrategy": "Test confirmation dialog appears, prevents accidental clicks, handles both cancellation modes, shows proper loading states, and displays success/error messages"
          },
          {
            "id": 4,
            "title": "Create Subscription Management Page Layout",
            "description": "Build main subscription page combining all components with proper layout",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create frontend/app/(auth)/subscription/page.tsx combining SubscriptionInfo, PaymentHistory, and CancelSubscriptionButton components. Implement responsive grid layout using Tailwind CSS. Add page title, breadcrumbs, and proper spacing. Include loading states for the entire page and error boundaries.",
            "status": "done",
            "testStrategy": "Test page layout renders correctly on all screen sizes, components are properly arranged, breadcrumbs work, and error boundaries catch component errors"
          },
          {
            "id": 5,
            "title": "Implement Authentication Handling",
            "description": "Add authentication checks and redirect logic for subscription page",
            "dependencies": [
              4
            ],
            "details": "Implement authentication middleware in subscription page to ensure only logged-in users can access. Add redirect logic to login page for unauthenticated users. Implement server-side user profile fetching using Supabase server client. Add proper TypeScript types for user session and profile data.",
            "status": "done",
            "testStrategy": "Test unauthenticated users get redirected to login, authenticated users can access page, server-side data fetching works correctly, and session handling is secure"
          },
          {
            "id": 6,
            "title": "Implement State Management and Data Fetching",
            "description": "Add state management for subscription data and real-time updates",
            "dependencies": [
              4,
              5
            ],
            "details": "Integrate TanStack Query for subscription data fetching and caching. Set up real-time subscriptions using Supabase for subscription status changes. Implement optimistic updates for subscription actions. Add proper error handling and retry logic. Create custom hooks for subscription data management.",
            "status": "done",
            "testStrategy": "Test data fetching works correctly, real-time updates reflect subscription changes, optimistic updates provide good UX, and error handling gracefully manages failures"
          }
        ]
      },
      {
        "id": 13,
        "title": "Razorpay Live Plans Creation and Configuration",
        "description": "Create live Razorpay plans and update configuration for production deployment",
        "details": "Create 6 live plans in Razorpay dashboard: Explorer (₹1,599), Navigator (₹3,299), Voyager (₹6,699), Crew (₹1,999), Fleet (₹5,399), Armada (₹10,899). Document plan IDs and update frontend/lib/config/razorpayPlans.ts with live plan IDs. Create frontend/scripts/createRazorpayPlans.ts script for automated plan creation. Configure live webhook URL in Razorpay dashboard, update environment variables for production with live API keys and webhook secret. Verify plan creation and configuration in Razorpay dashboard.",
        "testStrategy": "Verify all 6 plans created with correct pricing, plan IDs documented and updated in config, webhook URL configured correctly, environment variables set for production",
        "priority": "high",
        "dependencies": [
          12
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Live Razorpay Plans in Dashboard",
            "description": "Manually create all 6 live subscription plans in Razorpay dashboard with correct pricing and billing cycles",
            "dependencies": [],
            "details": "Access Razorpay live dashboard and create 6 subscription plans: Explorer (₹1,599/month), Navigator (₹3,299/month), Voyager (₹6,699/month), Crew (₹1,999/month), Fleet (₹5,399/month), Armada (₹10,899/month). Configure billing cycle as monthly, set appropriate plan names and descriptions. Document all generated plan IDs for configuration update.",
            "status": "done",
            "testStrategy": "Verify all 6 plans appear in Razorpay dashboard with correct pricing, billing cycles, and plan names match requirements"
          },
          {
            "id": 2,
            "title": "Update Razorpay Configuration with Live Plan IDs",
            "description": "Update frontend configuration files with live plan IDs from Razorpay dashboard",
            "dependencies": [
              1
            ],
            "details": "Update frontend/lib/config/razorpayPlans.ts file replacing test plan IDs with live plan IDs obtained from step 1. Ensure all 6 plans (Explorer, Navigator, Voyager, Crew, Fleet, Armada) have correct live plan IDs mapped to their respective tiers. Update any environment variables or configuration that reference plan IDs.",
            "status": "done",
            "testStrategy": "Verify configuration file contains all 6 live plan IDs, run typecheck to ensure no errors, test getPlanId function returns correct live IDs"
          },
          {
            "id": 3,
            "title": "Develop Automated Razorpay Plan Creation Script",
            "description": "Create TypeScript script to automate Razorpay plan creation for future deployments",
            "dependencies": [
              1
            ],
            "details": "Create frontend/scripts/createRazorpayPlans.ts script using Razorpay SDK to programmatically create all 6 subscription plans. Include error handling, plan validation, and option to update configuration file automatically. Add script to package.json as 'create-plans' command. Include documentation on how to use script for different environments.",
            "status": "done",
            "testStrategy": "Run script in test mode, verify it creates plans correctly, test error handling with invalid credentials, ensure it doesn't duplicate existing plans"
          },
          {
            "id": 4,
            "title": "Configure Production Environment and Webhooks",
            "description": "Set up live webhook URL, update environment variables, and configure production Razorpay settings",
            "dependencies": [
              1,
              2
            ],
            "details": "Configure live webhook URL in Razorpay dashboard pointing to production domain. Update production environment variables: NEXT_PUBLIC_RAZORPAY_KEY_ID (live key), RAZORPAY_KEY_SECRET (live secret), RAZORPAY_WEBHOOK_SECRET (live webhook secret). Verify webhook endpoint is accessible and responds correctly. Test webhook delivery with sample events.",
            "status": "done",
            "testStrategy": "Verify webhook URL configured in dashboard, test webhook endpoint responds with 200, verify environment variables set correctly in production, test sample webhook delivery"
          }
        ]
      },
      {
        "id": 14,
        "title": "Comprehensive Testing Suite Implementation",
        "description": "Implement unit tests, integration tests, and E2E tests for complete payment flow coverage",
        "details": "Create comprehensive test suites: Unit tests for all API routes with >90% coverage using Jest/Vitest, mocking Razorpay SDK and Supabase client. Integration tests for complete subscription flows using test database. E2E tests with Playwright testing pricing page → checkout → payment → dashboard flow using Razorpay test mode. Include tests for error scenarios, edge cases, webhook processing, idempotency, signature verification, rate limiting, and security measures. Create test fixtures and helper functions for consistent test data.",
        "testStrategy": "Run all test suites, verify >90% code coverage, ensure all happy paths and error cases covered, validate webhook event processing, confirm security measures work correctly",
        "priority": "high",
        "dependencies": [
          13
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Unit Test Suite Setup and Configuration",
            "description": "Set up comprehensive unit testing framework with Jest/Vitest configuration for API routes testing",
            "dependencies": [],
            "details": "Configure Jest/Vitest testing framework in frontend directory. Set up test configuration files (jest.config.js or vitest.config.ts), configure TypeScript support, set up test environment variables, and create initial test structure for API routes. Configure coverage reporting with >90% target and exclude patterns for non-testable code.",
            "status": "done",
            "testStrategy": "Verify test runner executes successfully, configuration loads correctly, and coverage reporting works"
          },
          {
            "id": 2,
            "title": "Mocking Setup for External Dependencies",
            "description": "Create comprehensive mocks for Razorpay SDK and Supabase client to enable isolated unit testing",
            "dependencies": [
              1
            ],
            "details": "Create mock implementations for Razorpay SDK methods (subscriptions.create, customers.create, plans.fetch), mock Supabase client with database operations (insert, select, update, delete), and authentication methods. Set up mock factories for consistent test data generation and response simulation including error scenarios.",
            "status": "done",
            "testStrategy": "Verify mocks return expected data structures and can simulate both success and error conditions"
          },
          {
            "id": 3,
            "title": "API Routes Unit Tests Implementation",
            "description": "Implement unit tests for all payment-related API routes with comprehensive coverage",
            "dependencies": [
              2
            ],
            "details": "Create unit tests for create-subscription, webhook processing, usage tracking, and billing routes. Test request validation, authentication checks, business logic, error handling, and response formats. Include tests for edge cases like invalid planId, expired tokens, malformed requests, and rate limiting scenarios.",
            "status": "done",
            "testStrategy": "Achieve >90% code coverage, test all happy paths and error scenarios, verify proper HTTP status codes"
          },
          {
            "id": 4,
            "title": "Integration Testing Framework Setup",
            "description": "Set up integration testing environment with test database and Razorpay test mode configuration",
            "dependencies": [
              3
            ],
            "details": "Configure test database environment using Supabase test instance or local PostgreSQL. Set up test data seeding and cleanup scripts. Configure Razorpay test mode with test API keys and webhook endpoints. Create integration test helpers for database operations and API request simulation.",
            "status": "done",
            "testStrategy": "Verify test database connectivity, data seeding/cleanup works, and Razorpay test mode integration functions"
          },
          {
            "id": 5,
            "title": "End-to-End Testing with Playwright",
            "description": "Implement E2E tests covering complete user journey from pricing page to successful payment",
            "dependencies": [
              4
            ],
            "details": "Set up Playwright testing framework and create E2E test scenarios: navigate to pricing page, select plan, proceed through checkout flow, complete payment using Razorpay test cards, verify dashboard updates with new subscription. Include error scenario tests for payment failures and timeout handling.",
            "status": "done",
            "testStrategy": "All E2E scenarios pass, user flows work end-to-end, error handling scenarios covered"
          },
          {
            "id": 6,
            "title": "Test Fixtures and Helper Functions",
            "description": "Create comprehensive test fixtures and utility functions for consistent test data generation",
            "dependencies": [
              1
            ],
            "details": "Develop test fixtures for user profiles, subscription plans, payment records, and webhook payloads. Create helper functions for database seeding, API request builders, mock data generation, and test assertion utilities. Include factories for different subscription tiers and payment scenarios.",
            "status": "done",
            "testStrategy": "Fixtures generate consistent data, helpers reduce test boilerplate, and utilities work across all test types"
          },
          {
            "id": 7,
            "title": "Security and Webhook Testing",
            "description": "Implement security-focused tests for webhook signature verification and authentication flows",
            "dependencies": [
              6
            ],
            "details": "Create tests for webhook signature verification using HMAC-SHA256, test idempotency handling for duplicate webhook events, verify rate limiting protection, test authentication bypass attempts, and validate RLS policy enforcement. Include tests for malicious payload handling and injection attempts.",
            "status": "done",
            "testStrategy": "Security tests pass, webhook verification works correctly, rate limiting enforced, no security vulnerabilities found"
          },
          {
            "id": 8,
            "title": "Coverage Analysis and Performance Testing",
            "description": "Implement code coverage analysis and performance benchmarking for the testing suite",
            "dependencies": [
              7
            ],
            "details": "Set up coverage reporting with Istanbul/c8, configure coverage thresholds (>90% for critical paths), implement performance testing for API endpoints with response time monitoring. Create performance benchmarks for webhook processing, subscription creation, and database operations. Generate coverage and performance reports.",
            "status": "done",
            "testStrategy": "Coverage targets met (>90%), performance benchmarks within acceptable limits (<500ms API responses), comprehensive reporting generated"
          }
        ]
      },
      {
        "id": 15,
        "title": "Security Audit and Performance Optimization",
        "description": "Conduct security review and performance testing to meet production requirements",
        "details": "Perform security audit: verify API keys not exposed in client bundle, webhook signature verification uses constant-time comparison, RLS policies prevent unauthorized access, rate limiting active on all routes, HTTPS enforced. Conduct performance testing: API response times <500ms (P95), database queries <100ms (P95), webhook processing <1s (P95), load testing with 100 concurrent users on pricing page and 50 concurrent subscriptions. Optimize slow queries, implement caching where appropriate, ensure no memory leaks under sustained load.",
        "testStrategy": "Security audit checklist completion, performance benchmarks met, load testing results within targets, no critical vulnerabilities found, optimization improvements documented",
        "priority": "high",
        "dependencies": [
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Security Audit Checklist Implementation",
            "description": "Conduct comprehensive security review covering API keys, authentication, authorization, and security best practices",
            "dependencies": [],
            "details": "Verify API keys not exposed in client bundle by checking build output and source maps. Audit webhook signature verification uses constant-time comparison to prevent timing attacks. Review all RLS policies to prevent unauthorized data access. Confirm rate limiting is active on all API routes with appropriate limits. Ensure HTTPS is enforced across all endpoints. Check for sensitive data exposure in logs, error messages, and client-side code. Validate input sanitization and XSS prevention measures.",
            "status": "done",
            "testStrategy": "Security checklist completion with documented findings, automated security scanning tools, manual code review of critical security components"
          },
          {
            "id": 2,
            "title": "Performance Benchmarking Setup",
            "description": "Establish performance baseline metrics and monitoring infrastructure for key system components",
            "dependencies": [
              1
            ],
            "details": "Set up performance monitoring for API response times with P95 target <500ms. Configure database query monitoring with P95 target <100ms. Implement webhook processing time tracking with P95 target <1s. Create monitoring dashboards for real-time performance visibility. Establish baseline metrics for current system performance. Set up automated performance regression detection.",
            "status": "pending",
            "testStrategy": "Performance monitoring infrastructure operational, baseline metrics established, automated alerts configured for performance degradation"
          },
          {
            "id": 3,
            "title": "Load Testing Implementation",
            "description": "Execute comprehensive load testing scenarios to validate system performance under concurrent user loads",
            "dependencies": [
              2
            ],
            "details": "Implement load testing with 100 concurrent users on pricing page to test static content delivery and API endpoints. Execute load testing with 50 concurrent subscription operations including payment processing and webhook handling. Test database connection pooling and query performance under load. Validate system stability during sustained high traffic. Monitor resource utilization (CPU, memory, database connections) during load tests.",
            "status": "pending",
            "testStrategy": "Load testing scenarios pass with all performance targets met, system remains stable under load, no critical failures or timeouts observed"
          },
          {
            "id": 4,
            "title": "Performance Optimization Implementation",
            "description": "Identify and implement optimizations for slow queries, caching strategies, and system bottlenecks",
            "dependencies": [
              3
            ],
            "details": "Analyze slow database queries and implement optimizations through indexing, query restructuring, or caching. Implement caching strategies for frequently accessed data using Redis or Next.js caching. Optimize API response payloads by reducing unnecessary data transfer. Implement connection pooling optimizations for database access. Address any memory leaks identified during testing. Optimize frontend bundle sizes and implement code splitting where beneficial.",
            "status": "pending",
            "testStrategy": "Performance improvements documented with before/after metrics, optimized queries meet performance targets, no memory leaks detected under sustained load"
          },
          {
            "id": 5,
            "title": "Monitoring and Alerting Setup",
            "description": "Configure comprehensive monitoring and alerting system for production readiness",
            "dependencies": [
              4
            ],
            "details": "Set up application performance monitoring (APM) with error tracking and performance insights. Configure alerts for API response time degradation, database performance issues, and webhook processing failures. Implement uptime monitoring for critical endpoints. Set up logging aggregation for security events, payment transactions, and system errors. Configure notification channels for different severity levels. Create monitoring dashboards for operations team.",
            "status": "pending",
            "testStrategy": "Monitoring system operational with all key metrics tracked, alerts trigger correctly for test scenarios, dashboards display accurate real-time data"
          },
          {
            "id": 6,
            "title": "Security and Performance Documentation",
            "description": "Document security audit findings, performance benchmarks, and operational procedures for production maintenance",
            "dependencies": [
              5
            ],
            "details": "Document all security audit findings with remediation status and recommendations. Create performance benchmark documentation with baseline metrics and optimization results. Document monitoring and alerting procedures for operations team. Create incident response runbooks for common security and performance issues. Document optimization techniques implemented and their impact. Provide recommendations for ongoing security and performance maintenance.",
            "status": "pending",
            "testStrategy": "Complete documentation available covering security audit results, performance benchmarks, monitoring procedures, and operational guidelines"
          }
        ]
      },
      {
        "id": 16,
        "title": "Production Deployment and Go-Live",
        "description": "Deploy to production, apply database migrations, and monitor initial transactions",
        "details": "Switch to live Razorpay keys in Vercel production environment, apply database migrations (0034-0037) to production with proper backup. Deploy to Vercel production via GitHub merge to main branch. Conduct smoke testing: complete real ₹1 transaction, verify webhook processing, confirm user tier upgrade, validate all production flows. Set up monitoring alerts for webhook failures, API errors, and payment issues. Monitor Vercel logs and Razorpay dashboard for first 24 hours. Document rollback procedures and emergency contacts.",
        "testStrategy": "Production deployment successful, smoke tests pass, monitoring active with no errors in first 10 transactions, rollback procedures tested and documented",
        "priority": "high",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Production Environment Variables",
            "description": "Switch from test to live Razorpay API keys in Vercel production environment and configure all necessary production variables",
            "dependencies": [],
            "details": "Update Vercel production environment variables: replace NEXT_PUBLIC_RAZORPAY_KEY_ID and RAZORPAY_KEY_SECRET with live keys from Razorpay dashboard. Verify RAZORPAY_WEBHOOK_SECRET matches production webhook endpoint. Ensure NEXT_PUBLIC_APP_URL points to production domain. Set NEXT_PUBLIC_ENABLE_PAYMENTS=true. Document all changes and verify no test keys remain in production.",
            "status": "done",
            "testStrategy": "Verify environment variables are accessible in production build, confirm live keys are active in Razorpay dashboard"
          },
          {
            "id": 2,
            "title": "Deploy Database Migrations to Production",
            "description": "Apply database migrations (0034-0037) to production Supabase with proper backup procedures",
            "dependencies": [
              1
            ],
            "details": "Create full database backup before migration. Apply migrations in sequence: 0034 (subscriptions table), 0035 (payments table), 0036 (webhook_events table), 0037 (user_profiles extension). Verify each migration applies successfully. Test foreign key relationships and RLS policies in production. Document migration completion and verify data integrity.",
            "status": "done",
            "testStrategy": "Confirm all tables created with correct schema, test RLS policies prevent unauthorized access, verify foreign key constraints work"
          },
          {
            "id": 3,
            "title": "Deploy Application to Vercel Production",
            "description": "Merge changes to main branch and deploy to Vercel production environment via GitHub integration",
            "dependencies": [
              2
            ],
            "details": "Create pull request with all Razorpay integration changes. Perform final code review and merge to main branch. Monitor Vercel deployment process and verify successful build completion. Check deployment logs for any errors or warnings. Verify production URL is accessible and application loads correctly with new payment features.",
            "status": "done",
            "testStrategy": "Confirm deployment successful with green status, verify production site loads without errors, check Vercel function logs for any issues"
          },
          {
            "id": 4,
            "title": "Execute Production Smoke Testing",
            "description": "Conduct comprehensive smoke testing including real ₹1 transaction and webhook verification",
            "dependencies": [
              3
            ],
            "details": "Complete end-to-end payment flow test: register new account, select Navigator plan, initiate ₹1 test payment using real payment method. Verify Razorpay webhook processing updates user tier correctly. Test subscription creation and payment confirmation. Verify blueprint creation limits updated according to new tier. Test all critical user flows work with new payment system.",
            "status": "done",
            "testStrategy": "Successfully complete ₹1 transaction, verify user tier upgraded from explorer to navigator, confirm webhook processed and payment recorded in database"
          },
          {
            "id": 5,
            "title": "Configure Production Monitoring and Alerts",
            "description": "Set up comprehensive monitoring for webhook failures, API errors, and payment processing issues",
            "dependencies": [
              4
            ],
            "details": "Configure Vercel monitoring for payment API routes with error rate and response time alerts. Set up Razorpay webhook monitoring and failure notifications. Create alert rules for failed payments, webhook processing errors, and subscription status changes. Configure email/Slack notifications for critical payment system issues. Set up dashboard for real-time payment system health monitoring.",
            "status": "done",
            "testStrategy": "Trigger test webhook failure and verify alert notification received, confirm API error monitoring detects simulated payment failures"
          },
          {
            "id": 6,
            "title": "Document Rollback Procedures and Emergency Contacts",
            "description": "Create comprehensive rollback documentation and establish emergency response procedures",
            "dependencies": [
              5
            ],
            "details": "Document step-by-step rollback procedures for reverting environment variables, database migrations, and application deployment. Create emergency contact list including Razorpay support, Vercel support, and internal team contacts. Document manual webhook processing procedures for system failures. Create incident response playbook for payment system outages. Store all documentation in accessible location with team access.",
            "status": "pending",
            "testStrategy": "Test rollback procedures in staging environment, verify emergency contacts are reachable, confirm documentation is complete and accessible"
          },
          {
            "id": 7,
            "title": "Conduct 24-Hour Post-Launch Monitoring",
            "description": "Monitor Vercel logs, Razorpay dashboard, and system metrics for first 24 hours after go-live",
            "dependencies": [
              6
            ],
            "details": "Continuously monitor Vercel function logs for payment-related errors during first 24 hours. Track Razorpay dashboard for payment success rates, failed transactions, and webhook delivery status. Monitor user registration and subscription conversion rates. Track database performance and query response times. Document any issues encountered and resolution steps taken. Prepare post-launch summary report.",
            "status": "pending",
            "testStrategy": "Zero critical errors in payment processing during monitoring period, webhook success rate >99%, all user payments processed correctly"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-10-28T18:36:42.638Z",
      "updated": "2025-10-29T19:08:51.443Z",
      "description": "Tasks for razorpay-integration context"
    }
  }
}