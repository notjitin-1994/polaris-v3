/**
 * Create Subscription API Route
 *
 * @description API endpoint for creating Razorpay subscriptions with comprehensive validation,
 * authentication, duplicate prevention, and error handling
 *
 * @version 1.0.0
 * @date 2025-10-29
 *
 * @endpoint POST /api/subscriptions/create-subscription
 * @access authenticated users
 */

import { NextResponse } from 'next/server';
import {
  CreateSubscriptionRequestSchema,
  CreateSubscriptionResponseSchema,
  ErrorResponseSchema,
  validateCreateSubscriptionRequest,
  type CreateSubscriptionRequest
} from '@/lib/schemas/razorpaySubscription';
import { getSupabaseServerClient, getServerSession } from '@/lib/supabase/server';
import type { Database } from '@/types/supabase';
import { getPlanId, getPlanPrice } from '@/lib/config/razorpayPlans';

// Set runtime configuration
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

/**
 * Rate limiting store (in-memory for development)
 * TODO: Replace with Redis for production
 */
const rateLimitStore = new Map<string, { count: number; resetTime: number }>();
const RATE_LIMIT_WINDOW = 60 * 1000; // 1 minute in milliseconds
const RATE_LIMIT_MAX_REQUESTS = 10; // 10 requests per minute per IP

/**
 * Generate unique request ID for tracking
 */
function generateRequestId(): string {
  return `req_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
}

/**
 * Check rate limit for IP address
 */
function checkRateLimit(ip: string): { allowed: boolean; resetTime?: number } {
  const now = Date.now();
  const existing = rateLimitStore.get(ip);

  if (!existing || now > existing.resetTime) {
    // Reset or create new entry
    rateLimitStore.set(ip, {
      count: 1,
      resetTime: now + RATE_LIMIT_WINDOW
    });
    return { allowed: true };
  }

  if (existing.count >= RATE_LIMIT_MAX_REQUESTS) {
    return { allowed: false, resetTime: existing.resetTime };
  }

  existing.count++;
  return { allowed: true };
}

/**
 * Structured error response utility
 */
function createErrorResponse(
  code: string,
  message: string,
  status: number,
  requestId: string,
  details?: any
): NextResponse {
  const errorResponse = {
    success: false,
    error: { code, message, details },
    requestId
  };

  return NextResponse.json(errorResponse, { status });
}

/**
 * Structured success response utility
 */
function createSuccessResponse(
  data: any,
  requestId: string
): NextResponse {
  return NextResponse.json({
    success: true,
    data,
    requestId
  });
}

/**
 * Main POST handler for subscription creation
 */
export async function POST(request: Request): Promise<Response> {
  const requestId = generateRequestId();
  const startTime = Date.now();

  try {
    // Extract client IP for rate limiting
    const ip = request.headers.get('x-forwarded-for') ||
               request.headers.get('x-real-ip') ||
               'unknown';

    // Rate limiting check
    const rateLimitResult = checkRateLimit(ip);
    if (!rateLimitResult.allowed) {
      console.warn(`[Razorpay] Rate limit exceeded for IP: ${ip}`, {
        requestId,
        ip,
        resetTime: rateLimitResult.resetTime
      });

      return createErrorResponse(
        'RATE_LIMIT_EXCEEDED',
        'Too many requests. Please try again later.',
        429,
        requestId,
        {
          resetTime: rateLimitResult.resetTime,
          limit: RATE_LIMIT_MAX_REQUESTS,
          windowMs: RATE_LIMIT_WINDOW
        }
      );
    }

    // Parse request body
    let requestBody: unknown;
    try {
      requestBody = await request.json();
    } catch (error) {
      console.error('[Razorpay] Invalid JSON body', {
        requestId,
        error: error instanceof Error ? error.message : 'Unknown error'
      });

      return createErrorResponse(
        'INVALID_JSON',
        'Invalid JSON in request body',
        400,
        requestId
      );
    }

    // Validate request body using Zod schema
    const validationResult = validateCreateSubscriptionRequest(requestBody);
    if (!validationResult.success) {
      console.error('[Razorpay] Validation failed', {
        requestId,
        errors: validationResult.error.flatten(),
        body: requestBody
      });

      return createErrorResponse(
        'VALIDATION_ERROR',
        'Invalid request parameters',
        400,
        requestId,
        {
          validationErrors: validationResult.error.flatten()
        }
      );
    }

    const { tier, billingCycle, seats, customerInfo, metadata } = validationResult.data;

    // Authentication check
    const sessionResult = await getServerSession();
    if (!sessionResult.session || !sessionResult.session.user) {
      console.error('[Razorpay] Authentication failed', {
        requestId,
        hasSession: !!sessionResult.session,
        hasUser: !!sessionResult.session?.user
      });

      return createErrorResponse(
        'UNAUTHORIZED',
        'Authentication required. Please sign in to create a subscription.',
        401,
        requestId
      );
    }

    const user = sessionResult.session.user;
    const userId = user.id;

    // Initialize Supabase client
    const supabase = await getSupabaseServerClient();

    // Get user profile for additional context
    const { data: userProfile, error: profileError } = await supabase
      .from('user_profiles')
      .select('subscription_tier, subscription_status, email, full_name')
      .eq('id', userId)
      .single();

    if (profileError) {
      console.error('[Razorpay] Failed to fetch user profile', {
        requestId,
        userId,
        error: profileError
      });

      return createErrorResponse(
        'PROFILE_ERROR',
        'Failed to retrieve user profile',
        500,
        requestId,
        { originalError: profileError.message }
      );
    }

    // Get plan configuration
    const planId = getPlanId(tier, billingCycle);
    if (!planId) {
      console.error('[Razorpay] Plan not configured', {
        requestId,
        tier,
        billingCycle
      });

      return createErrorResponse(
        'PLAN_NOT_CONFIGURED',
        `Plan not configured for ${tier} tier with ${billingCycle} billing`,
        400,
        requestId,
        { tier, billingCycle }
      );
    }

    const planPrice = getPlanPrice(tier, billingCycle);
    const planAmount = seats ? planPrice * seats : planPrice; // Multiply for team tiers

    console.log('[Razorpay] Subscription creation request validated', {
      requestId,
      userId: user.id,
      email: user.email,
      tier,
      billingCycle,
      seats,
      planId,
      planAmount,
      processingTime: Date.now() - startTime
    });

    // Check for existing active subscriptions (duplicate prevention)
    console.log('[Razorpay] Checking for existing subscriptions', {
      requestId,
      userId
    });

    const { data: existingSubscriptions, error: subscriptionCheckError } = await supabase
      .from('subscriptions')
      .select(`
        subscription_id,
        razorpay_subscription_id,
        status,
        subscription_tier,
        plan_name,
        next_billing_date,
        created_at,
        updated_at
      `)
      .eq('user_id', userId)
      .in('status', ['created', 'authenticated', 'active', 'trialing'])
      .is('deleted_at', null)
      .order('created_at', { ascending: false });

    if (subscriptionCheckError) {
      console.error('[Razorpay] Failed to check existing subscriptions', {
        requestId,
        userId,
        error: subscriptionCheckError
      });

      return createErrorResponse(
        'SUBSCRIPTION_CHECK_ERROR',
        'Failed to verify existing subscriptions',
        500,
        requestId,
        { originalError: subscriptionCheckError.message }
      );
    }

    // Handle duplicate subscription prevention
    if (existingSubscriptions && existingSubscriptions.length > 0) {
      const activeSubscription = existingSubscriptions[0];

      console.warn('[Razorpay] Duplicate subscription attempt detected', {
        requestId,
        userId,
        existingSubscription: {
          id: activeSubscription.subscription_id,
          status: activeSubscription.status,
          tier: activeSubscription.subscription_tier,
          nextBilling: activeSubscription.next_billing_date
        },
        newRequest: {
          tier,
          billingCycle
        }
      });

      // Allow upgrade to higher tier but prevent duplicate same tier
      const tierHierarchy = {
        'free': 0,
        'explorer': 1,
        'navigator': 2,
        'voyager': 3,
        'crew': 4,
        'fleet': 5,
        'armada': 6
      };

      const currentTierLevel = tierHierarchy[activeSubscription.subscription_tier as keyof typeof tierHierarchy] || 0;
      const requestedTierLevel = tierHierarchy[tier] || 0;

      if (requestedTierLevel <= currentTierLevel) {
        // Same tier or downgrade - prevent duplicate
        return createErrorResponse(
          'DUPLICATE_SUBSCRIPTION',
          `You already have an active ${activeSubscription.subscription_tier} subscription. ${requestedTierLevel === currentTierLevel ? 'Cannot create duplicate subscription.' : 'Please select a higher tier to upgrade.'}`,
          400,
          requestId,
          {
            currentSubscription: {
              tier: activeSubscription.subscription_tier,
              status: activeSubscription.status,
              planName: activeSubscription.plan_name,
              nextBillingDate: activeSubscription.next_billing_date
            },
            requestedTier: tier,
            isUpgradeAttempt: requestedTierLevel <= currentTierLevel
          }
        );
      } else {
        // Higher tier - allow upgrade but log it
        console.log('[Razorpay] Upgrade attempt detected', {
          requestId,
          userId,
          fromTier: activeSubscription.subscription_tier,
          toTier: tier,
          currentStatus: activeSubscription.status
        });
      }
    }

    console.log('[Razorpay] Subscription creation request validated', {
      requestId,
      userId: user.id,
      email: user.email,
      tier,
      billingCycle,
      seats,
      planId,
      planAmount,
      existingSubscriptionsCount: existingSubscriptions?.length || 0,
      processingTime: Date.now() - startTime
    });

    // TODO: Continue with Razorpay customer and subscription creation
    // This will be implemented in the next subtask

    return createSuccessResponse({
      message: 'Request validated successfully',
      subscriptionDetails: {
        userId,
        tier,
        billingCycle,
        seats,
        planId,
        planAmount,
        customerInfo,
        metadata,
        existingSubscriptions: existingSubscriptions || []
      }
    }, requestId);

  } catch (error: unknown) {
    console.error('[Razorpay] Unexpected error in subscription creation', {
      requestId,
      error: error instanceof Error ? error.message : 'Unknown error',
      stack: error instanceof Error ? error.stack : undefined,
      processingTime: Date.now() - startTime
    });

    return createErrorResponse(
      'INTERNAL_ERROR',
      'An unexpected error occurred while processing your request',
      500,
      requestId,
      {
        timestamp: new Date().toISOString(),
        processingTime: Date.now() - startTime
      }
    );
  }
}

/**
 * GET handler (not supported - only POST allowed)
 */
export async function GET(): Promise<Response> {
  return NextResponse.json(
    {
      success: false,
      error: {
        code: 'METHOD_NOT_ALLOWED',
        message: 'Only POST method is allowed for this endpoint'
      }
    },
    { status: 405 }
  );
}