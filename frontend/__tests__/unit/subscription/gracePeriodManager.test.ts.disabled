/**
 * Grace Period Manager Tests
 *
 * @description Test suite for grace period management functionality
 * including calculations, status tracking, and automated actions
 *
 * @version 1.0.0
 * @date 2025-10-30
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import {
  getGracePeriodConfig,
  getGracePeriodStatus,
  startGracePeriod,
  sendGracePeriodWarning,
  endGracePeriod,
  checkGracePeriodRestrictions,
  processAllGracePeriods,
} from '@/lib/subscription/gracePeriodManager';

// Mock dependencies
vi.mock('@/lib/supabase/server');
vi.mock('@/lib/monitoring/subscriptionMonitoring');

describe('Grace Period Manager', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('getGracePeriodConfig', () => {
    it('should return correct config for personal tiers', () => {
      const explorerConfig = getGracePeriodConfig('explorer');
      const navigatorConfig = getGracePeriodConfig('navigator');
      const voyagerConfig = getGracePeriodConfig('voyager');

      expect(explorerConfig.durationDays).toBe(7);
      expect(explorerConfig.endAction).toBe('downgrade');
      expect(explorerConfig.restrictedAccess).toBe(true);

      expect(navigatorConfig.durationDays).toBe(7);
      expect(voyagerConfig.durationDays).toBe(7);
    });

    it('should return correct config for team tiers', () => {
      const crewConfig = getGracePeriodConfig('crew');
      const fleetConfig = getGracePeriodConfig('fleet');
      const armadaConfig = getGracePeriodConfig('armada');

      expect(crewConfig.durationDays).toBe(14);
      expect(crewConfig.endAction).toBe('suspend');
      expect(crewConfig.restrictedAccess).toBe(true);

      expect(fleetConfig.durationDays).toBe(14);
      expect(armadaConfig.durationDays).toBe(14);
    });

    it('should return correct config for enterprise tier', () => {
      const enterpriseConfig = getGracePeriodConfig('enterprise');

      expect(enterpriseConfig.durationDays).toBe(30);
      expect(enterpriseConfig.endAction).toBe('suspend');
      expect(enterpriseConfig.restrictedAccess).toBe(false);
    });

    it('should return correct config for developer tier', () => {
      const developerConfig = getGracePeriodConfig('developer');

      expect(developerConfig.durationDays).toBe(90);
      expect(developerConfig.endAction).toBe('downgrade');
      expect(developerConfig.restrictedAccess).toBe(false);
    });

    it('should default to personal config for unknown tiers', () => {
      const unknownConfig = getGracePeriodConfig('unknown_tier');

      expect(unknownConfig.durationDays).toBe(7);
      expect(unknownConfig.endAction).toBe('downgrade');
      expect(unknownConfig.restrictedAccess).toBe(true);
    });
  });

  describe('checkGracePeriodRestrictions', () => {
    it('should allow all actions when not in grace period', async () => {
      vi.mocked(getGracePeriodStatus).mockResolvedValue({
        isInGracePeriod: false,
        restrictions: {
          canCreateBlueprints: false,
          canSaveBlueprints: false,
          canAccessPremiumFeatures: false,
          maxBlueprintsPerMonth: 0,
        },
      });

      const createResult = await checkGracePeriodRestrictions('user123', 'create_blueprint');
      const saveResult = await checkGracePeriodRestrictions('user123', 'save_blueprint');
      const premiumResult = await checkGracePeriodRestrictions(
        'user123',
        'access_premium_features'
      );

      expect(createResult.allowed).toBe(true);
      expect(saveResult.allowed).toBe(true);
      expect(premiumResult.allowed).toBe(true);
    });

    it('should restrict actions during grace period', async () => {
      vi.mocked(getGracePeriodStatus).mockResolvedValue({
        isInGracePeriod: true,
        daysRemaining: 5,
        restrictions: {
          canCreateBlueprints: false,
          canSaveBlueprints: false,
          canAccessPremiumFeatures: false,
          maxBlueprintsPerMonth: 0,
        },
      });

      const createResult = await checkGracePeriodRestrictions('user123', 'create_blueprint');
      const saveResult = await checkGracePeriodRestrictions('user123', 'save_blueprint');
      const premiumResult = await checkGracePeriodRestrictions(
        'user123',
        'access_premium_features'
      );

      expect(createResult.allowed).toBe(false);
      expect(saveResult.allowed).toBe(false);
      expect(premiumResult.allowed).toBe(false);
      expect(createResult.reason).toContain('restricted during grace period');
      expect(createResult.remainingDays).toBe(5);
    });

    it('should allow limited actions during grace period for some tiers', async () => {
      vi.mocked(getGracePeriodStatus).mockResolvedValue({
        isInGracePeriod: true,
        daysRemaining: 10,
        restrictions: {
          canCreateBlueprints: true,
          canSaveBlueprints: true,
          canAccessPremiumFeatures: false,
          maxBlueprintsPerMonth: 5,
        },
      });

      const createResult = await checkGracePeriodRestrictions('user123', 'create_blueprint');
      const saveResult = await checkGracePeriodRestrictions('user123', 'save_blueprint');
      const premiumResult = await checkGracePeriodRestrictions(
        'user123',
        'access_premium_features'
      );

      expect(createResult.allowed).toBe(true);
      expect(saveResult.allowed).toBe(true);
      expect(premiumResult.allowed).toBe(false);
      expect(premiumResult.reason).toContain('restricted during grace period');
    });
  });

  describe('Grace Period Calculation', () => {
    it('should calculate grace period dates correctly for immediate start', async () => {
      const now = new Date('2025-01-15T10:00:00Z');
      vi.useFakeTimers();
      vi.setSystemTime(now);

      // Mock user profile with expired subscription
      vi.doMock('@/lib/supabase/server', () => ({
        createClient: () => ({
          from: () => ({
            select: () => ({
              eq: () => ({
                single: () =>
                  Promise.resolve({
                    data: {
                      subscription_tier: 'explorer',
                      subscription_status: 'expired',
                      subscription_ends_at: '2025-01-10T00:00:00Z',
                      grace_period_start: null,
                      grace_period_end: null,
                      grace_period_warnings_sent: [],
                    },
                    error: null,
                  }),
              }),
            }),
          }),
        }),
      }));

      const status = await getGracePeriodStatus('user123');

      expect(status.isInGracePeriod).toBe(true);
      expect(status.daysRemaining).toBeGreaterThan(0);
      expect(status.gracePeriodStart).toBeDefined();
      expect(status.gracePeriodEnd).toBeDefined();

      vi.useRealTimers();
    });

    it('should handle different grace period durations for different tiers', async () => {
      const now = new Date('2025-01-15T10:00:00Z');
      vi.useFakeTimers();
      vi.setSystemTime(now);

      // Test different tiers
      const tiers = ['explorer', 'navigator', 'voyager', 'crew', 'enterprise'];
      const expectedDurations = [7, 7, 7, 14, 30]; // days

      for (let i = 0; i < tiers.length; i++) {
        const tier = tiers[i];

        vi.doMock('@/lib/supabase/server', () => ({
          createClient: () => ({
            from: () => ({
              select: () => ({
                eq: () => ({
                  single: () =>
                    Promise.resolve({
                      data: {
                        subscription_tier: tier,
                        subscription_status: 'expired',
                        subscription_ends_at: '2025-01-10T00:00:00Z',
                        grace_period_start: null,
                        grace_period_end: null,
                        grace_period_warnings_sent: [],
                      },
                      error: null,
                    }),
                }),
              }),
            }),
          }),
        }));

        const status = await getGracePeriodStatus(`user${tier}`);

        expect(status.isInGracePeriod).toBe(true);
        if (status.gracePeriodStart && status.gracePeriodEnd) {
          const actualDuration = Math.ceil(
            (status.gracePeriodEnd.getTime() - status.gracePeriodStart.getTime()) /
              (24 * 60 * 60 * 1000)
          );
          expect(actualDuration).toBe(expectedDurations[i]);
        }
      }

      vi.useRealTimers();
    });
  });

  describe('Grace Period Actions', () => {
    it('should start grace period for payment failure', async () => {
      const mockSupabase = {
        from: vi.fn()
          .mockReturnValueOnce({
            select: () => ({
              eq: () => ({
                single: () =>
                  Promise.resolve({
                    data: {
                      subscription_tier: 'explorer',
                      subscription_ends_at: '2025-01-20T00:00:00Z',
                    },
                    error: null,
                  }),
              }),
            }),
          })
          .mockReturnValueOnce({
            update: () => ({
              eq: () => Promise.resolve({ error: null }),
            }),
          })
          .mockReturnValueOnce({
            insert: () => Promise.resolve({ error: null }),
          }),
      };

      vi.doMock('@/lib/supabase/server', () => ({
        createClient: () => mockSupabase,
      }));

      await expect(startGracePeriod('user123', 'sub123', 'payment_failed')).resolves.not.toThrow();

      expect(mockSupabase.from).toHaveBeenCalled();
    });

    it('should send grace period warning', async () => {
      const now = new Date('2025-01-15T10:00:00Z');
      vi.useFakeTimers();
      vi.setSystemTime(now);

      const mockSupabase = {
        from: vi.fn()
          .mockReturnValueOnce({
            select: () => ({
              eq: () => ({
                single: () =>
                  Promise.resolve({
                    data: {
                      subscription_tier: 'explorer',
                      grace_period_end: '2025-01-22T10:00:00Z', // 7 days from now
                      grace_period_warnings_sent: [], // No warnings sent yet
                      email: 'user@example.com',
                    },
                    error: null,
                  }),
              }),
            }),
          })
          .mockReturnValueOnce({
            update: () => ({
              eq: () => Promise.resolve({ error: null }),
            }),
          }),
      };

      vi.doMock('@/lib/supabase/server', () => ({
        createClient: () => mockSupabase,
      }));

      await expect(sendGracePeriodWarning('user123', 3)).resolves.not.toThrow();

      vi.useRealTimers();
    });

    it('should end grace period and apply end action', async () => {
      const mockSupabase = {
        from: vi.fn()
          .mockReturnValueOnce({
            select: () => ({
              eq: () => ({
                single: () =>
                  Promise.resolve({
                    data: {
                      subscription_tier: 'explorer',
                      grace_period_reason: 'payment_failed',
                    },
                    error: null,
                  }),
              }),
            }),
          })
          .mockReturnValueOnce({
            update: () => ({
              eq: () => Promise.resolve({ error: null }),
            }),
          })
          .mockReturnValueOnce({
            insert: () => Promise.resolve({ error: null }),
          }),
      };

      vi.doMock('@/lib/supabase/server', () => ({
        createClient: () => mockSupabase,
      }));

      await expect(endGracePeriod('user123', 'sub123')).resolves.not.toThrow();

      expect(mockSupabase.from).toHaveBeenCalled();
    });

    it('should handle different end actions for different tiers', async () => {
      const testCases = [
        { tier: 'explorer', expectedAction: 'downgrade', expectedNewTier: 'explorer' },
        { tier: 'crew', expectedAction: 'suspend', expectedNewTier: 'crew' },
        { tier: 'enterprise', expectedAction: 'suspend', expectedNewTier: 'enterprise' },
        { tier: 'developer', expectedAction: 'downgrade', expectedNewTier: 'developer' },
      ];

      for (const testCase of testCases) {
        const mockSupabase = {
          from: vi.fn()
            .mockReturnValueOnce({
              select: () => ({
                eq: () => ({
                  single: () =>
                    Promise.resolve({
                      data: {
                        subscription_tier: testCase.tier,
                        grace_period_reason: 'payment_failed',
                      },
                      error: null,
                    }),
                }),
              }),
            })
            .mockReturnValueOnce({
              update: () => ({
                eq: () => Promise.resolve({ error: null }),
              }),
            })
            .mockReturnValueOnce({
              insert: () => Promise.resolve({ error: null }),
            }),
        };

        vi.doMock('@/lib/supabase/server', () => ({
          createClient: () => mockSupabase,
        }));

        await expect(endGracePeriod('user123', 'sub123')).resolves.not.toThrow();
      }
    });
  });

  describe('Automated Processing', () => {
    it('should process all grace periods and send warnings', async () => {
      const now = new Date('2025-01-15T10:00:00Z');
      vi.useFakeTimers();
      vi.setSystemTime(now);

      const mockUsers = [
        {
          id: 'user1',
          subscription_tier: 'explorer',
          grace_period_end: '2025-01-17T10:00:00Z', // 2 days - should send 3-day warning
          grace_period_warnings_sent: [],
          razorpay_subscription_id: 'sub1',
        },
        {
          id: 'user2',
          subscription_tier: 'crew',
          grace_period_end: '2025-01-20T10:00:00Z', // 5 days - should send 5-day warning
          grace_period_warnings_sent: [],
          razorpay_subscription_id: 'sub2',
        },
        {
          id: 'user3',
          subscription_tier: 'explorer',
          grace_period_end: '2025-01-14T10:00:00Z', // Yesterday - should end grace period
          grace_period_warnings_sent: [1, 3],
          razorpay_subscription_id: 'sub3',
        },
      ];

      const mockSupabase = {
        from: vi.fn().mockReturnValue({
          select: () => ({
            not: () => ({
              eq: () =>
                Promise.resolve({
                  data: mockUsers,
                  error: null,
                }),
            }),
          }),
        }),
      };

      vi.doMock('@/lib/supabase/server', () => ({
        createClient: () => mockSupabase,
      }));

      const result = await processAllGracePeriods();

      expect(result.processed).toBe(3);
      expect(result.warningsSent).toBeGreaterThan(0);
      expect(result.gracePeriodsEnded).toBeGreaterThan(0);

      vi.useRealTimers();
    });

    it('should handle errors during processing gracefully', async () => {
      const mockSupabase = {
        from: vi.fn().mockReturnValue({
          select: () => ({
            not: () => ({
              eq: () =>
                Promise.resolve({
                  data: [
                    {
                      id: 'user1',
                      subscription_tier: 'explorer',
                      grace_period_end: '2025-01-20T10:00:00Z',
                    },
                  ],
                  error: null,
                }),
            }),
          }),
        }),
      };

      vi.doMock('@/lib/supabase/server', () => ({
        createClient: () => mockSupabase,
      }));

      // Mock error in processing
      vi.doMock('@/lib/monitoring/subscriptionMonitoring', () => ({
        logEvent: () => Promise.reject(new Error('Logging failed')),
      }));

      const result = await processAllGracePeriods();

      expect(result.errors.length).toBeGreaterThan(0);
      expect(result.processed).toBe(1);
    });
  });

  describe('Edge Cases', () => {
    it('should handle missing user profile gracefully', async () => {
      const mockSupabase = {
        from: vi.fn().mockReturnValue({
          select: () => ({
            eq: () => ({
              single: () =>
                Promise.resolve({
                  data: null,
                  error: { message: 'User not found' },
                }),
            }),
          }),
        }),
      };

      vi.doMock('@/lib/supabase/server', () => ({
        createClient: () => mockSupabase,
      }));

      const status = await getGracePeriodStatus('nonexistent-user');

      expect(status.isInGracePeriod).toBe(false);
      expect(status.restrictions.canCreateBlueprints).toBe(false);
      expect(status.restrictions.canSaveBlueprints).toBe(false);
      expect(status.restrictions.canAccessPremiumFeatures).toBe(false);
    });

    it('should handle database errors gracefully', async () => {
      const mockSupabase = {
        from: vi.fn().mockReturnValue({
          select: () => ({
            eq: () => ({
              single: () =>
                Promise.resolve({
                  data: null,
                  error: { message: 'Database connection failed' },
                }),
            }),
          }),
        }),
      };

      vi.doMock('@/lib/supabase/server', () => ({
        createClient: () => mockSupabase,
      }));

      await expect(getGracePeriodStatus('user123')).resolves.toBeDefined();
    });

    it('should handle zero or negative days remaining', async () => {
      const now = new Date('2025-01-15T10:00:00Z');
      vi.useFakeTimers();
      vi.setSystemTime(now);

      vi.doMock('@/lib/supabase/server', () => ({
        createClient: () => ({
          from: vi.fn().mockReturnValue({
            select: () => ({
              eq: () => ({
                single: () =>
                  Promise.resolve({
                    data: {
                      subscription_tier: 'explorer',
                      grace_period_start: '2025-01-10T10:00:00Z',
                      grace_period_end: '2025-01-14T10:00:00Z', // Yesterday
                      grace_period_warnings_sent: [1, 3],
                    },
                    error: null,
                  }),
              }),
            }),
          }),
        }),
      }));

      const status = await getGracePeriodStatus('user123');

      expect(status.daysRemaining).toBeLessThan(0);
      expect(status.isInGracePeriod).toBe(false);

      vi.useRealTimers();
    });

    it('should handle corrupted grace period data', async () => {
      vi.doMock('@/lib/supabase/server', () => ({
        createClient: () => ({
          from: vi.fn().mockReturnValue({
            select: () => ({
              eq: () => ({
                single: () =>
                  Promise.resolve({
                    data: {
                      subscription_tier: 'explorer',
                      grace_period_start: 'invalid-date',
                      grace_period_end: 'also-invalid',
                      grace_period_warnings_sent: 'not-an-array',
                    },
                    error: null,
                  }),
              }),
            }),
          }),
        }),
      }));

      const status = await getGracePeriodStatus('user123');

      expect(status).toBeDefined();
      expect(typeof status.isInGracePeriod).toBe('boolean');
    });
  });

  describe('Security Tests', () => {
    it('should prevent unauthorized grace period manipulation', async () => {
      // This would be tested in the API route tests
      // Here we test the core logic doesn't allow bypassing restrictions
      vi.mocked(getGracePeriodStatus).mockResolvedValue({
        isInGracePeriod: true,
        daysRemaining: 1,
        restrictions: {
          canCreateBlueprints: false,
          canSaveBlueprints: false,
          canAccessPremiumFeatures: false,
          maxBlueprintsPerMonth: 0,
        },
      });

      const result = await checkGracePeriodRestrictions('user123', 'create_blueprint');

      expect(result.allowed).toBe(false);
      expect(result.reason).toContain('restricted during grace period');
    });

    it('should handle malicious input in grace period actions', async () => {
      const mockSupabase = {
        from: vi.fn()
          .mockReturnValueOnce({
            select: () => ({
              eq: () => ({
                single: () =>
                  Promise.resolve({
                    data: { subscription_tier: 'explorer' },
                    error: null,
                  }),
              }),
            }),
          })
          .mockReturnValueOnce({
            update: () => ({
              eq: () => Promise.resolve({ error: null }),
            }),
          }),
      };

      vi.doMock('@/lib/supabase/server', () => ({
        createClient: () => mockSupabase,
      }));

      // Test with malicious user ID
      await expect(
        startGracePeriod(' malicious_user_id <script>', 'sub123')
      ).resolves.not.toThrow();

      // Test with malicious subscription ID
      await expect(
        startGracePeriod('user123', ' malicious_subscription <script>')
      ).resolves.not.toThrow();
    });

    it('should not expose sensitive information in error messages', async () => {
      const mockSupabase = {
        from: vi.fn().mockReturnValue({
          select: () => ({
            eq: () => ({
              single: () =>
                Promise.resolve({
                  data: null,
                  error: {
                    message: 'Database connection failed: host=db.internal password=secret123',
                  },
                }),
            }),
          }),
        }),
      };

      vi.doMock('@/lib/supabase/server', () => ({
        createClient: () => mockSupabase,
      }));

      const status = await getGracePeriodStatus('user123');

      expect(status).toBeDefined();
      // Should not contain sensitive database info
      expect(status.nextAction.action).not.toContain('password=secret123');
      expect(status.nextAction.action).not.toContain('db.internal');
    });
  });
});