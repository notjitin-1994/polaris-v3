---
description: Rules for Claude Sonnet 4-powered learning blueprint generation with JSON schema and advanced visualization
globs: frontend/**/*
alwaysApply: false
---

# Claude-Powered Learning Blueprint Generation System

## **Architecture Overview**

- **Claude Sonnet 4 Primary**: Use `claude-sonnet-4-20250514` for cost-effective, high-quality blueprint generation
- **Claude Opus 4 Fallback**: Reserved for complex/failed generations requiring maximum reasoning
- **Ollama Emergency Fallback**: Local generation when both Claude models unavailable
- **Dynamic Schema Handling**: Support any JSON structure returned by LLM with seamless frontend rendering
- **Comprehensive Logging**: All operations logged to `/logs` with filtering and search
- **Zero Data Loss**: Robust error handling, retries, and database persistence

## **Claude Integration**

### API Configuration
```typescript
// Configuration for Claude blueprint generation
const CLAUDE_CONFIG = {
  primaryModel: 'claude-sonnet-4-20250514',
  fallbackModel: 'claude-opus-4-20250514', 
  apiKey: process.env.ANTHROPIC_API_KEY,
  baseUrl: process.env.ANTHROPIC_BASE_URL || 'https://api.anthropic.com',
  version: process.env.ANTHROPIC_VERSION || '2023-06-01',
  maxTokens: 12000,
  temperature: 0.2,
  timeout: 120000,
  retries: 2,
};
```

### System Prompt Structure
```typescript
const BLUEPRINT_SYSTEM_PROMPT = `You are an expert Learning Experience Designer with deep knowledge of instructional design principles, adult learning theory, and organizational development.

Your task is to generate comprehensive, industry-specific learning blueprints that:
- Align with ADDIE, SAM, or agile instructional design models
- Incorporate current L&D best practices (2024-2025)
- Are immediately actionable and implementation-ready
- Include measurable KPIs and assessment strategies
- Consider diverse learning modalities and accessibility

OUTPUT REQUIREMENTS:
1. Valid JSON only - no markdown, no preamble
2. Include display metadata for each section specifying visualization type
3. Use rich, descriptive content that demonstrates expertise
4. Provide specific, contextual recommendations (no generic advice)
5. Include citations/sources where applicable

VISUALIZATION TYPES:
- "infographic": For data-driven, visual dashboard displays
- "markdown": For narrative, formatted text content
- "chart": For quantitative data (specify chartType: bar/line/pie/radar)
- "timeline": For sequential/temporal information
- "table": For structured, comparative data

Be comprehensive yet concise. Every field should add value.`;
```

### User Prompt Template
```typescript
interface BlueprintContext {
  staticAnswers: Record<string, any>;
  dynamicAnswers: Record<string, any>;
  organization: string;
  role: string;
  industry: string;
  learningObjectives: string[];
}

const buildBlueprintPrompt = (context: BlueprintContext) => `
Generate a comprehensive learning blueprint based on the following inputs:

ORGANIZATION CONTEXT:
- Organization: ${context.organization}
- Industry: ${context.industry}
- Role: ${context.role}

STATIC QUESTIONNAIRE ANSWERS:
${JSON.stringify(context.staticAnswers, null, 2)}

DYNAMIC QUESTIONNAIRE ANSWERS:
${JSON.stringify(context.dynamicAnswers, null, 2)}

PRIMARY LEARNING OBJECTIVES:
${context.learningObjectives.map((obj, i) => `${i + 1}. ${obj}`).join('\n')}

OUTPUT SCHEMA:
{
  "metadata": {
    "title": "Blueprint Title",
    "organization": "${context.organization}",
    "role": "${context.role}",
    "generated_at": "${new Date().toISOString()}",
    "version": "1.0",
    "model": "claude-sonnet-4"
  },
  "executive_summary": {
    "content": "2-3 paragraph executive summary",
    "displayType": "markdown"
  },
  "learning_objectives": {
    "objectives": [
      {
        "id": "obj1",
        "title": "Objective title",
        "description": "Detailed description",
        "metric": "How success is measured",
        "baseline": "Current state",
        "target": "Desired outcome",
        "due_date": "Target completion date"
      }
    ],
    "displayType": "infographic",
    "chartConfig": {
      "type": "radar",
      "metrics": ["baseline", "target"]
    }
  },
  "target_audience": {
    "demographics": {
      "roles": ["Role 1", "Role 2"],
      "experience_levels": ["Junior", "Mid", "Senior"],
      "department_distribution": [
        {"department": "Engineering", "percentage": 40},
        {"department": "Product", "percentage": 30}
      ]
    },
    "learning_preferences": {
      "modalities": [
        {"type": "Visual", "percentage": 35},
        {"type": "Hands-on", "percentage": 45}
      ]
    },
    "displayType": "infographic"
  },
  "instructional_strategy": {
    "overview": "Strategy narrative",
    "modalities": [
      {
        "type": "Self-paced online",
        "rationale": "Why this modality fits",
        "allocation_percent": 40,
        "tools": ["Tool 1", "Tool 2"]
      }
    ],
    "cohort_model": "Description of cohort approach",
    "accessibility_considerations": ["Consideration 1", "Consideration 2"],
    "displayType": "markdown"
  },
  "content_outline": {
    "modules": [
      {
        "module_id": "m1",
        "title": "Module Title",
        "description": "Module overview",
        "topics": ["Topic 1", "Topic 2"],
        "duration": "2 weeks",
        "delivery_method": "Asynchronous + Live sessions",
        "learning_activities": [
          {
            "activity": "Activity description",
            "type": "Exercise/Discussion/Project",
            "duration": "30 minutes"
          }
        ],
        "assessment": {
          "type": "Quiz/Project/Presentation",
          "description": "Assessment details"
        }
      }
    ],
    "displayType": "timeline"
  },
  "resources": {
    "human_resources": [
      {"role": "Instructional Designer", "fte": 0.5, "duration": "3 months"},
      {"role": "Subject Matter Expert", "fte": 0.25, "duration": "6 weeks"}
    ],
    "tools_and_platforms": [
      {"category": "LMS", "name": "Canvas/Moodle", "cost_type": "Subscription"},
      {"category": "Content Authoring", "name": "Articulate 360", "cost_type": "License"}
    ],
    "budget": {
      "currency": "USD",
      "items": [
        {"item": "Content Development", "amount": 50000},
        {"item": "Tools & Licenses", "amount": 10000}
      ],
      "total": 60000
    },
    "displayType": "table"
  },
  "assessment_strategy": {
    "overview": "Assessment philosophy and approach",
    "kpis": [
      {
        "metric": "Completion Rate",
        "target": "85%",
        "measurement_method": "LMS analytics",
        "frequency": "Weekly"
      }
    ],
    "evaluation_methods": [
      {
        "method": "Knowledge Checks",
        "timing": "End of each module",
        "weight": "20%"
      }
    ],
    "displayType": "infographic",
    "chartConfig": {
      "type": "bar",
      "metric": "target"
    }
  },
  "implementation_timeline": {
    "phases": [
      {
        "phase": "Design",
        "start_date": "2025-01-01",
        "end_date": "2025-02-15",
        "milestones": ["Milestone 1", "Milestone 2"],
        "dependencies": []
      }
    ],
    "critical_path": ["Phase 1", "Phase 2"],
    "displayType": "timeline"
  },
  "risk_mitigation": {
    "risks": [
      {
        "risk": "Low engagement",
        "probability": "Medium",
        "impact": "High",
        "mitigation_strategy": "Specific mitigation actions"
      }
    ],
    "contingency_plans": ["Plan A", "Plan B"],
    "displayType": "table"
  },
  "success_metrics": {
    "metrics": [
      {
        "metric": "Metric name",
        "current_baseline": "Current value",
        "target": "Target value",
        "measurement_method": "How to measure",
        "timeline": "When to achieve"
      }
    ],
    "reporting_cadence": "Weekly/Monthly",
    "dashboard_requirements": ["Requirement 1", "Requirement 2"],
    "displayType": "infographic"
  },
  "sustainability_plan": {
    "content": "Long-term sustainability narrative",
    "maintenance_schedule": {
      "review_frequency": "Quarterly",
      "update_triggers": ["Trigger 1", "Trigger 2"]
    },
    "scaling_considerations": ["Consideration 1", "Consideration 2"],
    "displayType": "markdown"
  }
}

CRITICAL REQUIREMENTS:
1. Return ONLY valid JSON (no markdown code fences, no explanatory text)
2. Include displayType for EVERY top-level section
3. Use specific, contextual content (not generic templates)
4. Include chartConfig when displayType is "chart" or "infographic" with charts
5. Ensure all dates are ISO format strings
6. All monetary amounts should be numbers
7. Percentages should be numbers (0-100)
8. Be comprehensive but avoid unnecessary verbosity
`;
```

## **Blueprint Generation Service**

### Service Architecture
```typescript
// /frontend/lib/services/blueprintGenerationService.ts

import { createServiceLogger } from '@/lib/logging';

const logger = createServiceLogger('blueprint-generation');

interface GenerationResult {
  success: boolean;
  blueprint: BlueprintJSON;
  metadata: {
    model: 'claude-sonnet-4' | 'claude-opus-4' | 'ollama';
    duration: number;
    timestamp: string;
    fallbackUsed: boolean;
  };
  error?: string;
}

class BlueprintGenerationService {
  /**
   * Primary generation flow:
   * 1. Try Claude Sonnet 4
   * 2. On failure, try Claude Opus 4
   * 3. On failure, try Ollama
   */
  async generate(context: BlueprintContext): Promise<GenerationResult> {
    const startTime = Date.now();
    
    logger.info('blueprint.generation.started', {
      blueprintId: context.blueprintId,
      userId: context.userId,
    });
    
    // Try Claude Sonnet 4 (primary)
    try {
      const blueprint = await this.generateWithClaude(
        context,
        CLAUDE_CONFIG.primaryModel
      );
      
      const duration = Date.now() - startTime;
      logger.info('blueprint.generation.claude_success', {
        blueprintId: context.blueprintId,
        model: 'claude-sonnet-4',
        duration,
      });
      
      return {
        success: true,
        blueprint,
        metadata: {
          model: 'claude-sonnet-4',
          duration,
          timestamp: new Date().toISOString(),
          fallbackUsed: false,
        },
      };
    } catch (error) {
      logger.warn('blueprint.generation.claude_primary_failed', {
        blueprintId: context.blueprintId,
        error: (error as Error).message,
        attemptingFallback: true,
      });
      
      // Try Claude Opus 4 (fallback)
      try {
        const blueprint = await this.generateWithClaude(
          context,
          CLAUDE_CONFIG.fallbackModel
        );
        
        const duration = Date.now() - startTime;
        logger.info('blueprint.generation.claude_fallback_success', {
          blueprintId: context.blueprintId,
          model: 'claude-opus-4',
          duration,
        });
        
        return {
          success: true,
          blueprint,
          metadata: {
            model: 'claude-opus-4',
            duration,
            timestamp: new Date().toISOString(),
            fallbackUsed: true,
          },
        };
      } catch (fallbackError) {
        logger.error('blueprint.generation.claude_fallback_failed', {
          blueprintId: context.blueprintId,
          error: (fallbackError as Error).message,
          attemptingOllama: true,
        });
        
        // Try Ollama (emergency fallback)
        try {
          const blueprint = await this.generateWithOllama(context);
          
          const duration = Date.now() - startTime;
          logger.info('blueprint.generation.ollama_success', {
            blueprintId: context.blueprintId,
            duration,
          });
          
          return {
            success: true,
            blueprint,
            metadata: {
              model: 'ollama',
              duration,
              timestamp: new Date().toISOString(),
              fallbackUsed: true,
            },
          };
        } catch (ollamaError) {
          const duration = Date.now() - startTime;
          logger.error('blueprint.generation.all_failed', {
            blueprintId: context.blueprintId,
            duration,
            error: (ollamaError as Error).message,
          });
          
          throw new Error('All blueprint generation methods failed');
        }
      }
    }
  }
  
  private async generateWithClaude(
    context: BlueprintContext,
    model: string
  ): Promise<BlueprintJSON> {
    const systemPrompt = BLUEPRINT_SYSTEM_PROMPT;
    const userPrompt = buildBlueprintPrompt(context);
    
    const response = await fetch('/api/claude/generate-blueprint', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model,
        systemPrompt,
        userPrompt,
        blueprintId: context.blueprintId,
      }),
    });
    
    if (!response.ok) {
      throw new Error(`Claude API error: ${response.statusText}`);
    }
    
    const data = await response.json();
    return this.validateAndNormalize(data.blueprint);
  }
  
  private async generateWithOllama(
    context: BlueprintContext
  ): Promise<BlueprintJSON> {
    // Use existing Ollama client
    const ollamaClient = new OllamaClient();
    const systemPrompt = BLUEPRINT_SYSTEM_PROMPT;
    const userPrompt = buildBlueprintPrompt(context);
    
    const blueprint = await ollamaClient.generateBlueprint(
      systemPrompt,
      userPrompt
    );
    
    return this.validateAndNormalize(blueprint);
  }
  
  private validateAndNormalize(blueprint: any): BlueprintJSON {
    // Validate structure
    if (!blueprint || typeof blueprint !== 'object') {
      throw new Error('Invalid blueprint structure');
    }
    
    // Ensure all sections have displayType
    const sections = Object.keys(blueprint).filter(key => 
      key !== 'metadata' && typeof blueprint[key] === 'object'
    );
    
    for (const section of sections) {
      if (!blueprint[section].displayType) {
        logger.warn('blueprint.validation.missing_display_type', {
          section,
          assignedDefault: 'markdown',
        });
        blueprint[section].displayType = 'markdown';
      }
    }
    
    return blueprint;
  }
}

export const blueprintGenerationService = new BlueprintGenerationService();
```

## **API Endpoints**

### POST `/api/claude/generate-blueprint`
```typescript
// /frontend/app/api/claude/generate-blueprint/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth/session';
import { createServiceLogger } from '@/lib/logging';

const logger = createServiceLogger('api');

export async function POST(req: NextRequest) {
  try {
    const session = await getSession();
    if (!session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    
    const { model, systemPrompt, userPrompt, blueprintId } = await req.json();
    
    // Validate inputs
    if (!systemPrompt || !userPrompt || !blueprintId) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }
    
    // Call Claude API
    const response = await fetch(
      `${CLAUDE_CONFIG.baseUrl}/v1/messages`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': CLAUDE_CONFIG.apiKey!,
          'anthropic-version': CLAUDE_CONFIG.version,
        },
        body: JSON.stringify({
          model: model || CLAUDE_CONFIG.primaryModel,
          max_tokens: CLAUDE_CONFIG.maxTokens,
          temperature: CLAUDE_CONFIG.temperature,
          system: systemPrompt,
          messages: [
            {
              role: 'user',
              content: userPrompt,
            },
          ],
        }),
      }
    );
    
    if (!response.ok) {
      const errorText = await response.text();
      logger.error('claude.api.error', {
        status: response.status,
        error: errorText,
        blueprintId,
      });
      throw new Error(`Claude API error: ${response.statusText}`);
    }
    
    const data = await response.json();
    const content = data.content[0].text;
    
    // Parse JSON from response
    let blueprint;
    try {
      blueprint = JSON.parse(content);
    } catch (parseError) {
      logger.error('claude.response.parse_error', {
        blueprintId,
        content: content.substring(0, 500),
      });
      throw new Error('Failed to parse Claude response as JSON');
    }
    
    logger.info('claude.generation.success', {
      blueprintId,
      model,
      tokenUsage: data.usage,
    });
    
    return NextResponse.json({
      success: true,
      blueprint,
      usage: data.usage,
    });
  } catch (error) {
    logger.error('claude.generation.error', {
      error: (error as Error).message,
    });
    
    return NextResponse.json(
      { error: 'Blueprint generation failed' },
      { status: 500 }
    );
  }
}
```

### POST `/api/blueprints/generate`
```typescript
// Main blueprint generation endpoint
// Orchestrates: Context gathering → Generation → Database save → Response

export async function POST(req: NextRequest) {
  try {
    const session = await getSession();
    if (!session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    
    const { blueprintId } = await req.json();
    
    // Fetch blueprint with answers
    const blueprint = await fetchBlueprintWithAnswers(
      blueprintId,
      session.user.id
    );
    
    if (!blueprint) {
      return NextResponse.json(
        { error: 'Blueprint not found' },
        { status: 404 }
      );
    }
    
    // Build context
    const context: BlueprintContext = {
      blueprintId,
      userId: session.user.id,
      staticAnswers: blueprint.static_answers,
      dynamicAnswers: blueprint.dynamic_answers,
      organization: blueprint.static_answers.organization,
      role: blueprint.static_answers.role,
      industry: blueprint.static_answers.industry,
      learningObjectives: extractLearningObjectives(blueprint.dynamic_answers),
    };
    
    // Generate blueprint
    const result = await blueprintGenerationService.generate(context);
    
    if (!result.success) {
      return NextResponse.json(
        { error: result.error || 'Generation failed' },
        { status: 500 }
      );
    }
    
    // Convert to markdown for legacy compatibility
    const markdown = convertBlueprintToMarkdown(result.blueprint);
    
    // Save to database
    await saveBlueprintToDatabase(
      blueprintId,
      session.user.id,
      result.blueprint,
      markdown,
      result.metadata
    );
    
    return NextResponse.json({
      success: true,
      blueprintId,
      metadata: result.metadata,
    });
  } catch (error) {
    logger.error('blueprint.generation.endpoint_error', {
      error: (error as Error).message,
    });
    
    return NextResponse.json(
      { error: 'Failed to generate blueprint' },
      { status: 500 }
    );
  }
}
```

## **Dynamic Visualization System**

### Blueprint Viewer Components
```typescript
// /frontend/components/blueprint/BlueprintViewer.tsx

interface BlueprintViewerProps {
  blueprint: BlueprintJSON;
  view: 'infographic' | 'markdown';
}

export function BlueprintViewer({ blueprint, view }: BlueprintViewerProps) {
  const sections = Object.entries(blueprint).filter(
    ([key]) => key !== 'metadata'
  );
  
  return (
    <div className="space-y-8">
      {sections.map(([sectionKey, sectionData]) => (
        <BlueprintSection
          key={sectionKey}
          sectionKey={sectionKey}
          data={sectionData}
          viewMode={view}
        />
      ))}
    </div>
  );
}

interface BlueprintSectionProps {
  sectionKey: string;
  data: any;
  viewMode: 'infographic' | 'markdown';
}

function BlueprintSection({ sectionKey, data, viewMode }: BlueprintSectionProps) {
  const displayType = data.displayType || 'markdown';
  
  // Force markdown view if user selected it
  const effectiveDisplayType = viewMode === 'markdown' ? 'markdown' : displayType;
  
  switch (effectiveDisplayType) {
    case 'infographic':
      return <InfographicSection sectionKey={sectionKey} data={data} />;
    
    case 'timeline':
      return <TimelineSection sectionKey={sectionKey} data={data} />;
    
    case 'table':
      return <TableSection sectionKey={sectionKey} data={data} />;
    
    case 'chart':
      return <ChartSection sectionKey={sectionKey} data={data} />;
    
    case 'markdown':
    default:
      return <MarkdownSection sectionKey={sectionKey} data={data} />;
  }
}
```

### Infographic Section Component
```typescript
// Industry-leading infographic visualization
function InfographicSection({ sectionKey, data }: SectionProps) {
  const sectionTitle = formatSectionTitle(sectionKey);
  
  return (
    <div className="glass rounded-2xl p-8">
      <h2 className="text-title text-foreground mb-6">{sectionTitle}</h2>
      
      {/* Render based on data structure */}
      {data.objectives && (
        <ObjectivesInfographic objectives={data.objectives} />
      )}
      
      {data.metrics && (
        <MetricsInfographic metrics={data.metrics} chartConfig={data.chartConfig} />
      )}
      
      {data.modules && (
        <ModulesInfographic modules={data.modules} />
      )}
      
      {/* Fallback for unknown structures */}
      {!data.objectives && !data.metrics && !data.modules && (
        <GenericInfographic data={data} />
      )}
    </div>
  );
}

// Example: Objectives visualization with motion graphics
function ObjectivesInfographic({ objectives }: { objectives: Objective[] }) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
      {objectives.map((obj, index) => (
        <motion.div
          key={obj.id}
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: index * 0.1 }}
          className="glass-strong rounded-xl p-6 hover:scale-105 transition-transform"
        >
          <div className="flex items-start justify-between mb-4">
            <div className="text-primary text-3xl font-bold">
              #{index + 1}
            </div>
            <div className="text-secondary text-sm">
              {obj.due_date}
            </div>
          </div>
          
          <h3 className="text-heading text-foreground mb-2">
            {obj.title}
          </h3>
          
          <p className="text-body text-text-secondary mb-4">
            {obj.description}
          </p>
          
          <div className="space-y-2">
            <div className="flex justify-between">
              <span className="text-sm text-text-secondary">Baseline:</span>
              <span className="text-sm text-foreground font-medium">
                {obj.baseline}
              </span>
            </div>
            <div className="flex justify-between">
              <span className="text-sm text-text-secondary">Target:</span>
              <span className="text-sm text-primary font-medium">
                {obj.target}
              </span>
            </div>
          </div>
          
          {/* Progress bar */}
          <div className="mt-4">
            <div className="h-2 bg-surface rounded-full overflow-hidden">
              <motion.div
                className="h-full bg-gradient-to-r from-primary to-secondary"
                initial={{ width: 0 }}
                animate={{ width: '100%' }}
                transition={{ delay: index * 0.1 + 0.3, duration: 0.8 }}
              />
            </div>
          </div>
        </motion.div>
      ))}
    </div>
  );
}
```

## **Database Operations**

### Save Generated Blueprint
```typescript
async function saveBlueprintToDatabase(
  blueprintId: string,
  userId: string,
  blueprintJson: BlueprintJSON,
  blueprintMarkdown: string,
  metadata: GenerationMetadata
): Promise<void> {
  const supabase = await getSupabaseServerClient();
  
  // Store generation metadata in blueprint_json
  const blueprintWithMetadata = {
    ...blueprintJson,
    _generation_metadata: metadata,
  };
  
  const { error } = await supabase
    .from('blueprint_generator')
    .update({
      blueprint_json: blueprintWithMetadata,
      blueprint_markdown: blueprintMarkdown,
      status: 'completed',
      updated_at: new Date().toISOString(),
    })
    .eq('id', blueprintId)
    .eq('user_id', userId);
  
  if (error) {
    logger.error('blueprint.save.error', {
      blueprintId,
      userId,
      error: error.message,
    });
    throw new Error('Failed to save blueprint to database');
  }
  
  logger.info('blueprint.save.success', {
    blueprintId,
    userId,
    model: metadata.model,
  });
}
```

## **Logging Integration**

### Log Events for Blueprint Generation
```typescript
// All events logged to /logs page

const LOG_EVENTS = {
  GENERATION_STARTED: 'blueprint.generation.started',
  GENERATION_SUCCESS: 'blueprint.generation.success',
  GENERATION_FAILED: 'blueprint.generation.failed',
  CLAUDE_PRIMARY_SUCCESS: 'blueprint.claude.primary.success',
  CLAUDE_PRIMARY_FAILED: 'blueprint.claude.primary.failed',
  CLAUDE_FALLBACK_SUCCESS: 'blueprint.claude.fallback.success',
  CLAUDE_FALLBACK_FAILED: 'blueprint.claude.fallback.failed',
  OLLAMA_FALLBACK_SUCCESS: 'blueprint.ollama.fallback.success',
  OLLAMA_FALLBACK_FAILED: 'blueprint.ollama.fallback.failed',
  VALIDATION_FAILED: 'blueprint.validation.failed',
  SAVE_SUCCESS: 'blueprint.save.success',
  SAVE_FAILED: 'blueprint.save.failed',
  DISPLAY_TYPE_MISSING: 'blueprint.display_type.missing',
  UNKNOWN_SECTION_TYPE: 'blueprint.section_type.unknown',
};

// ✅ DO: Log all critical operations with context
logger.info(LOG_EVENTS.GENERATION_STARTED, {
  blueprintId,
  userId,
  hasStaticAnswers: !!staticAnswers,
  hasDynamicAnswers: !!dynamicAnswers,
});

logger.info(LOG_EVENTS.CLAUDE_PRIMARY_SUCCESS, {
  blueprintId,
  model: 'claude-sonnet-4',
  duration,
  tokenUsage: response.usage,
});

logger.warn(LOG_EVENTS.DISPLAY_TYPE_MISSING, {
  section: sectionKey,
  assignedDefault: 'markdown',
});
```

## **Error Handling & Resilience**

### Retry Logic
```typescript
async function withRetry<T>(
  fn: () => Promise<T>,
  options: {
    maxRetries: number;
    delayMs: number;
    backoffMultiplier: number;
  }
): Promise<T> {
  let lastError: Error;
  
  for (let attempt = 1; attempt <= options.maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;
      
      if (attempt < options.maxRetries) {
        const delay = options.delayMs * Math.pow(options.backoffMultiplier, attempt - 1);
        
        logger.warn('operation.retry', {
          attempt,
          maxRetries: options.maxRetries,
          nextRetryIn: delay,
          error: lastError.message,
        });
        
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  throw lastError!;
}
```

### Graceful Degradation
```typescript
// Handle missing or malformed sections
function renderSectionSafely(sectionData: any) {
  try {
    // Attempt normal render
    return <NormalSectionRender data={sectionData} />;
  } catch (error) {
    logger.warn('blueprint.render.fallback', {
      error: (error as Error).message,
      sectionData: JSON.stringify(sectionData).substring(0, 200),
    });
    
    // Fallback to JSON display
    return (
      <div className="glass rounded-xl p-6 border border-warning">
        <p className="text-warning mb-4">
          Unable to render section with standard visualizations
        </p>
        <pre className="text-xs text-text-secondary overflow-auto">
          {JSON.stringify(sectionData, null, 2)}
        </pre>
      </div>
    );
  }
}
```

## **Testing Requirements**

### Unit Tests
```typescript
describe('BlueprintGenerationService', () => {
  it('should generate blueprint with Claude Sonnet 4', async () => {
    const result = await blueprintGenerationService.generate(mockContext);
    expect(result.success).toBe(true);
    expect(result.metadata.model).toBe('claude-sonnet-4');
  });
  
  it('should fallback to Claude Opus 4 on primary failure', async () => {
    // Mock primary failure
    jest.spyOn(global, 'fetch').mockRejectedValueOnce(new Error('API error'));
    
    const result = await blueprintGenerationService.generate(mockContext);
    expect(result.metadata.model).toBe('claude-opus-4');
    expect(result.metadata.fallbackUsed).toBe(true);
  });
  
  it('should validate and normalize blueprint structure', () => {
    const blueprint = { metadata: {}, content: { text: 'test' } };
    const normalized = service.validateAndNormalize(blueprint);
    expect(normalized.content.displayType).toBe('markdown');
  });
});
```

### Integration Tests
```typescript
describe('Blueprint Generation API', () => {
  it('should generate and save blueprint end-to-end', async () => {
    const response = await fetch('/api/blueprints/generate', {
      method: 'POST',
      body: JSON.stringify({ blueprintId: testBlueprintId }),
    });
    
    expect(response.ok).toBe(true);
    const data = await response.json();
    expect(data.success).toBe(true);
    
    // Verify database save
    const { data: blueprint } = await supabase
      .from('blueprint_generator')
      .select('blueprint_json, status')
      .eq('id', testBlueprintId)
      .single();
    
    expect(blueprint.status).toBe('completed');
    expect(blueprint.blueprint_json).toBeDefined();
  });
});
```

## **Security Best Practices**

### API Key Management
```typescript
// ✅ DO: Keep API keys server-side only
const ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY;

// ❌ DON'T: Never expose in client bundles
const API_KEY = 'sk-ant-abc123'; // NEVER

// ✅ DO: Validate presence
if (!ANTHROPIC_API_KEY) {
  throw new Error('ANTHROPIC_API_KEY environment variable is required');
}
```

### Data Validation
```typescript
// ✅ DO: Validate all user inputs
function validateBlueprintContext(context: unknown): BlueprintContext {
  const schema = z.object({
    blueprintId: z.string().uuid(),
    userId: z.string().uuid(),
    staticAnswers: z.record(z.any()),
    dynamicAnswers: z.record(z.any()),
  });
  
  return schema.parse(context);
}

// ✅ DO: Verify ownership before operations
async function verifyBlueprintOwnership(
  blueprintId: string,
  userId: string
): Promise<boolean> {
  const { data } = await supabase
    .from('blueprint_generator')
    .select('id')
    .eq('id', blueprintId)
    .eq('user_id', userId)
    .single();
  
  return !!data;
}
```

## **Performance Optimization**

### Caching Strategy
```typescript
// Consider caching for identical questionnaire answers
const blueprintCache = new Map<string, CachedBlueprint>();

function getCacheKey(context: BlueprintContext): string {
  return hashObject({
    staticAnswers: context.staticAnswers,
    dynamicAnswers: context.dynamicAnswers,
  });
}

async function generateWithCache(
  context: BlueprintContext
): Promise<GenerationResult> {
  const cacheKey = getCacheKey(context);
  
  if (blueprintCache.has(cacheKey)) {
    logger.info('blueprint.cache.hit', { cacheKey });
    return blueprintCache.get(cacheKey)!;
  }
  
  const result = await blueprintGenerationService.generate(context);
  blueprintCache.set(cacheKey, result);
  
  return result;
}
```

### Progressive Loading
```typescript
// Load blueprint sections progressively for large documents
function BlueprintViewerProgressive({ blueprintId }: { blueprintId: string }) {
  const [sections, setSections] = useState<Section[]>([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    async function loadSections() {
      // Load metadata first
      const metadata = await fetchBlueprintMetadata(blueprintId);
      setSections([{ type: 'metadata', data: metadata }]);
      
      // Load remaining sections incrementally
      const sectionKeys = Object.keys(metadata.sections);
      for (const key of sectionKeys) {
        const section = await fetchBlueprintSection(blueprintId, key);
        setSections(prev => [...prev, { type: key, data: section }]);
      }
      
      setLoading(false);
    }
    
    loadSections();
  }, [blueprintId]);
  
  return (
    <div>
      {sections.map(section => (
        <BlueprintSection key={section.type} {...section} />
      ))}
      {loading && <LoadingSkeleton />}
    </div>
  );
}
```

## **Anti-Patterns to Avoid**

- **❌ DON'T** expose Claude API keys client-side
- **❌ DON'T** skip validation of LLM responses
- **❌ DON'T** assume all sections have expected structure
- **❌ DON'T** fail the entire blueprint for one malformed section
- **❌ DON'T** log sensitive user data or complete questionnaire answers
- **❌ DON'T** block UI during generation (use proper loading states)
- **❌ DON'T** save partial blueprints without clear status indicators
- **❌ DON'T** hardcode visualization types (use displayType metadata)

## **Quality Checklist**

Before marking tasks complete:

- [ ] Claude Sonnet 4 integration tested with real API
- [ ] Fallback to Opus 4 activates correctly
- [ ] Ollama emergency fallback works
- [ ] All sections render in both infographic and markdown views
- [ ] Unknown section structures gracefully degrade
- [ ] Database saves include all required fields
- [ ] Comprehensive logging to `/logs` endpoint
- [ ] Security audit passed (no exposed keys)
- [ ] Tests pass with >85% coverage
- [ ] Backward compatible with existing blueprints
- [ ] Performance meets targets (<60s generation)
- [ ] Mobile-responsive visualizations

---

Follow [taskmaster/dev_workflow.mdc](mdc:.cursor/rules/taskmaster/dev_workflow.mdc) for task-master workflow integration.
